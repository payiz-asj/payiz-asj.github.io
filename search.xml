<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>希腊字母及读音</title>
    <url>/%E7%AC%94%E8%AE%B0/Greek-alphabet/</url>
    <content><![CDATA[<p>给大家安利一张表格，方便记下希腊字母的读音。</p>
<span id="more"></span>



<table>
<thead>
<tr>
<th>大写</th>
<th>小写</th>
<th>英文注音</th>
<th>中文读音</th>
</tr>
</thead>
<tbody><tr>
<td>Α</td>
<td>α</td>
<td>alpha</td>
<td>阿尔法</td>
</tr>
<tr>
<td>Β</td>
<td>β</td>
<td>beta</td>
<td>贝塔</td>
</tr>
<tr>
<td>Γ</td>
<td>γ</td>
<td>gamma</td>
<td>伽马</td>
</tr>
<tr>
<td>Δ</td>
<td>δ</td>
<td>delta</td>
<td>德尔塔</td>
</tr>
<tr>
<td>Ε</td>
<td>ε</td>
<td>epsilon</td>
<td>伊普西龙</td>
</tr>
<tr>
<td>Ζ</td>
<td>ζ</td>
<td>zeta</td>
<td>截塔</td>
</tr>
<tr>
<td>Η</td>
<td>η</td>
<td>eta</td>
<td>艾塔</td>
</tr>
<tr>
<td>Θ</td>
<td>θ</td>
<td>theta</td>
<td>西塔</td>
</tr>
<tr>
<td>Ι</td>
<td>ι</td>
<td>iota</td>
<td>约塔</td>
</tr>
<tr>
<td>Κ</td>
<td>κ</td>
<td>kappa</td>
<td>卡帕</td>
</tr>
<tr>
<td>∧</td>
<td>λ</td>
<td>lambda</td>
<td>兰布达</td>
</tr>
<tr>
<td>Μ</td>
<td>μ</td>
<td>mu</td>
<td>缪</td>
</tr>
<tr>
<td>Ν</td>
<td>ν</td>
<td>nu</td>
<td>纽</td>
</tr>
<tr>
<td>Ξ</td>
<td>ξ</td>
<td>xi</td>
<td>克西</td>
</tr>
<tr>
<td>Ο</td>
<td>ο</td>
<td>omicron</td>
<td>奥密克戎</td>
</tr>
<tr>
<td>∏</td>
<td>π</td>
<td>pi</td>
<td>派</td>
</tr>
<tr>
<td>Ρ</td>
<td>ρ</td>
<td>rho</td>
<td>肉</td>
</tr>
<tr>
<td>∑</td>
<td>σ</td>
<td>sigma</td>
<td>西格马</td>
</tr>
<tr>
<td>Τ</td>
<td>τ</td>
<td>tau</td>
<td>套</td>
</tr>
<tr>
<td>Υ</td>
<td>υ</td>
<td>upsilon</td>
<td>宇普西龙</td>
</tr>
<tr>
<td>Φ</td>
<td>φ</td>
<td>phi</td>
<td>佛爱</td>
</tr>
<tr>
<td>Χ</td>
<td>χ</td>
<td>chi</td>
<td>西</td>
</tr>
<tr>
<td>Ψ</td>
<td>ψ</td>
<td>psi</td>
<td>普西</td>
</tr>
<tr>
<td>Ω</td>
<td>ω</td>
<td>omega</td>
<td>欧米伽</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>希腊字母</tag>
      </tags>
  </entry>
  <entry>
    <title>NJU 足球赛程管理系统</title>
    <url>/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/NJU-FOOTBALL/</url>
    <content><![CDATA[<p>​        为了方便学校足球爱好者们及时查看校内足球赛程，花 3 天自学 SQL Server + C# ，制作了一个界面化 Windows 端桌面程序。期间学习到的东西很多！</p>
<h2 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h2><p>项目名称：NJU足球赛程管理系统<br>项目环境：Sql Server 2019 + Visual Studio 2019<br>项目编程语言：Sql Server + C#.net<br>日期：2020.12.18 04:24 (UTC+08:00)</p>
<p>项目描述：<br>    提供针对NJU足球赛事的赛程查询、增加、修改、删除等功能，方便同学们自助关注NJU足球赛事。<br>    程序界面由Visual Studio 2019 利用C#.Net语言WPF框架开发，后端数据则保存在Sql Server Express数据库中，利用 SQL Server Management Studio (SSMS)  2018中创建和管理，同时也在VS中通过ADO.Net技术进行连接和操纵。</p>
<span id="more"></span>

<h2 id="项目过程："><a href="#项目过程：" class="headerlink" title="项目过程："></a>项目过程：</h2><p>​        （1）<strong>创建数据库：</strong>首先使用SSMS工具链接本地数据库服务器并创建数据库、创建表，然后编辑数据或从EXEL自动导入数据。</p>
<p>下图为导出的创建脚本和数据库数据：</p>
  <table>
      <tr> 
          <td><img src="https://pic.imgdb.cn/item/6104faf45132923bf8f9939b.png" border=0></td> 
            <td><img src="https://pic.imgdb.cn/item/6104faf45132923bf8f99389.png" border=0></td> 
      </tr>
</table>  

<p>​        （2）<strong>软件开发：</strong>打开我最爱的VS2019，开始创作！创建项目、设计前端界面，编写后端代码。</p>
<p>这里我放一下项目“解决方案管理器截屏吧”：</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61050a3f5132923bf8366f76.png" style = "height:300px"></img></p>
<p>稍微介绍一下：</p>
<p>​        本次项目使用的界面框架为C#中的WPF，比传统的WinForm强大、高级。XAML的编写风格有点像HTML，所以写起来简直舒服！我采用了前后端分离技术，前端只负责界面，后端负责程序逻辑和与数据库交互，前后端通过数据绑定来连接。</p>
<p>​        （3）<strong>数据库连接和操纵：</strong>这里我用了两个绝佳的方案：APP.config里增加命名空间“connectionStrings”，操纵SQL Server封装在SqlHelper类中</p>
  <table>
      <tr><img src="https://pic.imgdb.cn/item/610502b25132923bf81a536d.png" border=0></tr> 
      <tr><img src="https://pic.imgdb.cn/item/610502b25132923bf81a5354.png" border=0></tr> 
</table>  

<p>​        （4）<strong>界面优化：</strong> 使用阿里巴巴矢量图库iconFont下载了一些合适的icons来美化前端界面，并用我喜欢的足球明星们来当背景。赛程信息界面是C罗和梅西，主界面置顶背景为球王马拉多纳，上个月因病逝世，真的很遗憾啊！一代球神！希望您安息！</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610505bd5132923bf82601b6.png" style = "height:300px"></img></p>
<h2 id="项目结果展示："><a href="#项目结果展示：" class="headerlink" title="项目结果展示："></a>项目结果展示：</h2><table>
    <tr>
        <td colspan = "2" align = "center" ><img src="https://pic.imgdb.cn/item/6105070e5132923bf82acbe5.png" style = "height:300px"</img></td>
    </tr>
      <tr> 
          <td><img src="https://pic.imgdb.cn/item/610506e55132923bf82a37d9.png" border=0></td> 
            <td><img src="https://pic.imgdb.cn/item/610506e55132923bf82a37ea.png" border=0></td> 
      </tr>
</table>  



<h2 id="项目遇到的坑及处理方案"><a href="#项目遇到的坑及处理方案" class="headerlink" title="项目遇到的坑及处理方案"></a>项目遇到的坑及处理方案</h2><p>​        世界上最痛苦的事情莫过于过一段时间看自己以前的代码！😂</p>
<p>​        因此，我养成了一个好习惯，那就是做注释、写项目日志。其中记录学到的知识、遇到的坑以及相应的解决方案。</p>
<p>​        下面我贴几个本项目的学习心得和bug日志，方便大家参考：</p>
<p>（1）坑00：教学视频参考</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因为是刚自学，而网上关于C#的帖子、回答等都好几年前的，毫无参考价值！</span><br><span class="line">因此前面进度非常慢，后来B站上看到一个近期发表的教学视频，从中受益颇多！</span><br><span class="line">如果有刚学C#的朋友看到这里里，那就恭喜您，真的能少走弯路了，包括我下面遇到的 坑01-坑05  ！！！</span><br><span class="line">时间就是金钱，快看看这个视频吧！</span><br><span class="line">https://www.bilibili.com/video/BV1Wt411Z76N?p=1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>（2）坑01：C#中连接Sql Server</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">连接数据库时，需要检查服务器名是否正确，一般服务器名是个目标数据库的ip，如果是本地服务器的话，网上说可以用一个点（.）或者local，但是没成功！</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">我将服务器名改成SSMS中服务器属性中的名字（我的笔记本电脑的名字+SQLEXPRESS）才连接成功。</span><br><span class="line">例如：payiz\\SQLEXPRESS</span><br><span class="line">参考网址：</span><br><span class="line">http://c.biancheng.net/view/3010.html</span><br><span class="line">https://blog.csdn.net/yenange/article/details/77026214</span><br><span class="line">https://www.bilibili.com/video/BV1Wt411Z76N?p=15</span><br><span class="line">http://c.biancheng.net/view/3017.html</span><br><span class="line"></span><br><span class="line">此外，链接数据库，进行数据库语句执行时，一定要注意异常处理和资源释放的问题！</span><br><span class="line">可以使用try catch ,但更推荐用using关键字来释放资源！（非常重要！非常重要！非常重要！）</span><br><span class="line"></span><br><span class="line">此外，数据库连接字段可以放到项目配置文件中，这样就不用每次都重写连接字段，项目管理、移植起来更方便</span><br><span class="line">具体做法:</span><br><span class="line">1.项目根目录添加一个“应用程序配置文件”，名字为App.config，通常WPF项目创建会自动生成</span><br><span class="line">2.App.config中添加节点，给add起一个name</span><br><span class="line">3.项目添加对System.configuration的引用（可以理解为开发包，头文件）</span><br><span class="line">4.使用ConfigurationManager类（System.configuration里面的）来获取配置文件中的字段</span><br><span class="line">5.例如：string connStr = ConfigurationManager.ConnectionStrings[&quot;dbConnStr&quot;].ConnectionString;</span><br><span class="line"></span><br><span class="line">此外，数据库的链接查询操作也不用每次都重新写一遍，更高级的用法是用一个类来封装，我们称之为SqlHelper类</span><br><span class="line">具体做法可参考：https://www.bilibili.com/video/BV1Wt411Z76N?p=22</span><br></pre></td></tr></table></figure>
<p>（3）坑02：C#窗体的尺寸、最大化、最小化、图标Icon之类的才哪里改？</p>
<pre><code>解决方案：
方法一：选中窗体，在右边属性窗口里更改
方法二：在页面配置文件（.xaml）里写相应代码，例如：
&lt;Window x:Class=&quot;NJU足球赛程管理系统.MainWindow&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
    xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
    xmlns:local=&quot;clr-namespace:NJU足球赛程管理系统&quot;
    mc:Ignorable=&quot;d&quot;
    Title=&quot;NJU足球赛程管理系统&quot; Height=&quot;600&quot; Width=&quot;800&quot; MinWidth=&quot;800&quot; MinHeight=&quot;600&quot; Left=&quot;200&quot; Top=&quot;100&quot; MaxWidth=&quot;800&quot; MaxHeight=&quot;600&quot; 
    WindowState=&quot;Normal&quot; ShowInTaskbar=&quot;True&quot; ResizeMode=&quot;CanMinimize&quot; Icon = &quot;./images/zuqiu.png&quot; WindowStartupLocation=&quot;CenterScreen&quot;
    &gt;
注意：如果不知道Window这个类还有哪些属性和方法，则可以选中Window这个类，按F12，进入该类的声明查看（这个很重要！以后遇到任何陌生的类，都可以查看其声明）
</code></pre>
<p>（4）坑03：C# 窗体之间如何实现跳转？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">在需要跳转的地方可以用这个代码进行跳跃</span><br><span class="line"></span><br><span class="line">AddWindow aw = new AddWindow();  //先声明需要跳转的窗体类的实例对象</span><br><span class="line">this.Hide();                    //隐藏当前窗体，如过不是系统初始窗体，也可以用this.close()关闭掉,因为初始对话框被关闭的话程序就退出了（当然这个也是有办法解决的）。</span><br><span class="line">aw.ShowDialog();                //跳转，ShowDialog()和Show()二者的区别要注意，前者为模态对话框（跳转后原对话框不可操作），后者为非模态（跳转后原对话框仍可操作）。</span><br><span class="line">this.Show();                    //跳转后的对话框</span><br><span class="line"></span><br><span class="line">这里如果我说的不清楚还可以上网查一下，我留个参考网址：https://www.cnblogs.com/zhiaiyaya/archive/2014/03/12/3595275.html</span><br></pre></td></tr></table></figure>

<p>（5）坑04：Sql Server中填入数据时直接从Exel表格中导入</p>
<pre><code>解决方案：
非常简单，所以就放一下我参考的网址：
https://blog.csdn.net/marko_zheng/article/details/86005538
https://www.cnblogs.com/lzhc/p/8568500.html
https://docs.microsoft.com/zh-cn/sql/integration-services/import-export-data/connect-to-an-excel-data-source-sql-server-import-and-export-wizard?view=sql-server-ver15

如果连接exel出错，可以安装：Microsoft.ACE.OLEDB.16.0
请确保已下载 Access 数据库引擎 2016 可再发行组件，而不是 Microsoft Access 2016 Runtime 。
下载网址：https://docs.microsoft.com/zh-cn/sql/integration-services/load-data-to-from-excel-with-ssis?view=sql-server-ver15#files-you-need
</code></pre>
<p>（6）坑05：C#数据绑定机制</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">如何将界面中的控件和后台数据绑定，实现后台数据实时更新界面上控件的内容。</span><br><span class="line">经过一整天的探索，我现在确定了问题的关键：数据绑定</span><br><span class="line"></span><br><span class="line">解决方案：</span><br><span class="line">在成熟的程序开发中大家都会尽量避免在后台数据更新时直接操纵前端界面控件，取而代之的是将后台数据和前端界面控件进行数据绑定。数据绑定！数据绑定！数据绑定！真的很重要，且很强大！</span><br><span class="line"></span><br><span class="line">话不多说，我就直接放我寻找了一整天后觉得最有用的参考网址吧！看了能少走弯路，加油！</span><br><span class="line">https://www.bilibili.com/video/BV1Wt411Z76N?p=1</span><br><span class="line">https://docs.microsoft.com/zh-cn/visualstudio/xaml-tools/walkthrough-binding-to-data-in-xaml-designer?view=vs-2019</span><br></pre></td></tr></table></figure>


<h2 id="项目心得"><a href="#项目心得" class="headerlink" title="项目心得"></a>项目心得</h2><p>​        从0开始自学Sql Server 和C#，而且程序交付时间很紧迫，所以珍惜每分每秒，这3天过得像过了一个星期一样！在学习和制作过程踩了很多坑，但也在解决困难过程中学习了好多知识，也让我前后端分离、数据绑定、记录项目日志等编程习惯得到了很好的锻炼，最后写出来的程序“高内聚低耦合”，非常漂亮！</p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Sql Server</tag>
      </tags>
  </entry>
  <entry>
    <title>建立博客心路历程</title>
    <url>/%E5%8D%9A%E4%B8%BB%E5%AF%84%E8%AF%AD/blog-creation-process/</url>
    <content><![CDATA[<h1 align="center">建立博客心路历程</h1>
​        还记得大一时就有老师告诉我们：“大家可以尝试在网上写博客、文章，好让自己记录下学习的点点滴滴，也可以跟他人交流经验，那将是件非常不错的事情。”

<p>​        我大一就做了微信个人公众号，但是可惜啊，就写了一两片文章就没能坚持。后来在CSDN和博客园、知乎、简书等零零散散写了一些文章也没后文。</p>
<p>​        到现在终于下决心做个博客，花了3天3夜时间几乎没休息，啃完了HTML+CSS+JS大概用法，并且使用Gitpages+hexo成功搭建了这个免费的个人博客，说实话用Github这么长时间了了，现才才知道这个好东西，真是有点惭愧啊！</p>
<p>​        <strong>下面写一下我建立此博客的过程和心得吧，希望大家能够从中受益！</strong>👉</p>
<span id="more"></span>

<h3 id="1-搭建Github-Pages-hexo-博客环境"><a href="#1-搭建Github-Pages-hexo-博客环境" class="headerlink" title="1. 搭建Github Pages + hexo 博客环境"></a>1. 搭建Github Pages + hexo 博客环境</h3><p>​        这方面网上别人写的教程太多了，也可以参考<a href="https://hexo.io/zh-cn/docs/setup">hexo官网资料</a>，如果你是超级新手，我可以推荐一个非常用心的博主，他的教程能够手把手教会你搭建自己的博客！<a href="https://www.yunyoujun.cn/share/how-to-build-your-site/">云游君</a></p>
<h3 id="2-选择一个好看的主题来部署"><a href="#2-选择一个好看的主题来部署" class="headerlink" title="2. 选择一个好看的主题来部署"></a>2. 选择一个好看的主题来部署</h3><p>​        这部分就看个人喜好了，网上的hexo主题有几千种，选择喜欢的部署就可以。哈哈，其实选主题是个大坑，因为主题都是别人写的，看明白他人代码并修改真的能让人痛苦到死！😂</p>
<p>​        所以选一个自己喜欢的，有维护的或者自己有能力修改的主题很重要！</p>
<h3 id="3-博客美化"><a href="#3-博客美化" class="headerlink" title="3. 博客美化"></a>3. 博客美化</h3><p>​        我希望我的个人博客有一个好听的名字，一个好的意境。幸好因一次偶然机会让我找到了我想要的结果！🤟🤟</p>
<h3 id="4-购买域名"><a href="#4-购买域名" class="headerlink" title="4. 购买域名"></a>4. 购买域名</h3><p>​        想好博客名字后，觉得xxxx.github.io这个名字看起来太土，因此我申请了域名，因为现在只是静态页面，所以没考虑买服务器，暂时就用Gihub Page来充当服务器。</p>
<h3 id="5-写文章"><a href="#5-写文章" class="headerlink" title="5. 写文章"></a>5. 写文章</h3><p>​        写文章要坚持，而且不一定只写技术文章，也可以写一写生活中有意义的事情！对吧！加油！💪💪</p>
<h3 id="6-说一下我自己遇到过得坑吧"><a href="#6-说一下我自己遇到过得坑吧" class="headerlink" title="6. 说一下我自己遇到过得坑吧"></a>6. 说一下我自己遇到过得坑吧</h3><p>​        新手刚开始不要尝试修改别人的主题！我刚开始就选择了一个 特别好看的主题，但是其风格太主观化，处处能看到只属于原作者，因此我想改一改代码，增加我自己的风格。</p>
<p>​        结果，看了好几天，就是硬啃，我这个小白只能连蒙带猜地把源代码改一改比较一下效果，时刻在github备份版本。在尝试了无数次，遇到无数bug并一一解决，回退了无数次版本之后，终于知道了我的博客背后的逻辑，知道了hexo的运作机制，config.yml，layout , source， public， post, scaffolds这些文件及文件夹的原理，才算是成功了。我乘胜追击，又下载了好几个主题，看看能不能修改，加点自己的想法，嘿嘿😅</p>
<p>​        最后选择了现在这个主题，有了侧边栏、白天-黑夜模式、相册、RSS等，已经满足了我的期望了！</p>
<p>​        有几个界面（404页面、关于我页面、相册页面等）努力了近一个月才终于成功，期间也知道了CDN加速和图床的重要性，探索后使用了<a href="https://www.jsdelivr.com/">JsDelivr</a>来做CDN加速，<a href="https://www.superbed.cn/">聚合图床</a>来做个人图床。也从<a href="https://www.iconfont.cn/">阿里巴巴标准矢量图库</a>下载了好多图标做网站美化。</p>
<p>​        购买域名，我暂时买了一年，以后可能看情况续费或者买别的域名。新手刚开始就买一些便宜一点的即可。   </p>
<p>​        <strong>把所有的bug经历一遍并调会，你就是专家了！加油！勇敢迈出第一步🦶</strong></p>
<p>
    <img align ="center" src = "https://pic.imgdb.cn/item/60ffcc995132923bf8a1ffc0.jpg" style= "width:500px"/>
    <p align ="center">探索永不止步</p>
</p>    

]]></content>
      <categories>
        <category>博主寄语</category>
      </categories>
      <tags>
        <tag>欢迎</tag>
      </tags>
  </entry>
  <entry>
    <title>博客初建</title>
    <url>/%E5%8D%9A%E4%B8%BB%E5%AF%84%E8%AF%AD/blog-firstday/</url>
    <content><![CDATA[<h1 align="center">HELLO 👋</h1>
您好，

<p>​        欢迎来到我的个人博客！</p>
<p>​        平时会抽空分享一些技术文章和我学习、生活中一些有趣的事情。🎶</p>
<p>​        此外，还可通过 “ 首页-&gt;社交 “ ，到达我在其他几个主流网站上的个人首页，希望能给您奉上有意义的内容。💪</p>
<p>​        您还可以通过邮箱联系我，来投稿或提出宝贵意见，期待您的来信！💬</p>
]]></content>
      <categories>
        <category>博主寄语</category>
      </categories>
      <tags>
        <tag>欢迎</tag>
      </tags>
  </entry>
  <entry>
    <title>足协杯小组赛第一场</title>
    <url>/%E7%9B%B8%E5%86%8C/football-match-04-06/</url>
    <content><![CDATA[<h1 align = "center">足协杯小组赛第一场</h1>
<h3 align = "center">地海 3:1 政管</h3>
### **本学期第一场硬仗，狭路相逢勇者胜，赢得痛快！**


<table>
      <tr> 
          <td align = "center"><img src="https://pic.imgdb.cn/item/6101154e5132923bf8a8e7ff.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/6101154e5132923bf8a8e827.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/6101154e5132923bf8a8e856.jpg" style = "width:380px; height:214px" border=0></td> 
      </tr>
           <tr> 
          <td align = "center"><img src="https://pic.imgdb.cn/item/6101154e5132923bf8a8e8b2.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/6101154e5132923bf8a8e886.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/610116055132923bf8ab64f9.jpg" style = "width:380px; height:214px" border=0></td> 
      </tr>
            <tr> 
          <td align = "center"><img src="https://pic.imgdb.cn/item/610116055132923bf8ab6510.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/610116055132923bf8ab6531.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/610116055132923bf8ab654a.jpg" style = "width:380px; height:214px" border=0></td> 
      </tr>
</table>  
]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>足球比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>足协杯1/4决赛</title>
    <url>/%E7%9B%B8%E5%86%8C/football-match-06-03/</url>
    <content><![CDATA[<h1 align = "center">足协杯1/4决赛</h1>
<h3 align = "center">电子6:7地海</h3>



<p>遇到了本学期第一场点球大战，好在赛前一天大家练过，没得问题！</p>
<h2 id="首发阵容"><a href="#首发阵容" class="headerlink" title="首发阵容"></a>首发阵容</h2><p><img align = "center" src = "https://pic.imgdb.cn/item/610121c45132923bf8e1c7cb.png" style = "with:480px; height:414px"></img></p>
<h2 id="比赛赛况"><a href="#比赛赛况" class="headerlink" title="比赛赛况"></a>比赛赛况</h2><p><img align = "center" src = "https://pic.imgdb.cn/item/610121c45132923bf8e1c7e6.png" style = "with:480px; height:414px"></img></p>
<h2 id="赛场风采"><a href="#赛场风采" class="headerlink" title="赛场风采"></a><strong>赛场风采</strong></h2><p><img align = "center" src = "https://pic.imgdb.cn/item/610121c45132923bf8e1c806.png" style = "with:380px; height:214px"></img></p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610121c55132923bf8e1cb21.png" style = "with:380px; height:214px"></img></p>
]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>足球比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>足协杯半决赛</title>
    <url>/%E7%9B%B8%E5%86%8C/football-match-06-06/</url>
    <content><![CDATA[<h1 align = "center">闯入半决赛</h1>
<h3 align = "center">地海 2:1 环境 </h3>
北京时间6月6日晚20点20分,骄阳散去后的晚间，南风微拂，2020/21赛季南京大学足协杯半决赛第二场较量在仙林校区四组团足球场打响，由地理与海洋科学学院迎战环境学院。上半场双方地海占据主动，艾山江造点程智涵主罚命中，程智涵任意球世界波破门，包凯文近距离抽射被扑;环境以防守反击为主，陈泓宇点射命中，随后再次点球被化解。下半场双方互有攻守，地海队换上艾尔肯，后者连得两张黄牌被罚出场，程智涵任意球被没收，阿卜杜拉多次关键解围；环境进攻转化率有限，白玛朗杰远射未果，最终地海2-1战胜环境，以全胜战绩闯入足协杯决赛！

<p><strong>比赛直播及回放：<a href="https://wechat.ingsoccer.com.cn/web/events/live/21898">https://wechat.ingsoccer.com.cn/web/events/live/21898</a></strong></p>
<h2 id="详细战报"><a href="#详细战报" class="headerlink" title="详细战报"></a>详细战报</h2><h3 id="开场第10分钟，"><a href="#开场第10分钟，" class="headerlink" title="开场第10分钟，"></a>开场第10分钟，</h3><p>地海队持续进攻取得成效。艾山江突破造点，程智涵操刀主罚一蹴而就，地海队率先打破场上僵局。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610120b35132923bf8de3b29.png" style = "with:380px; height:214px"></img></p>
<p>第12分钟，地海队再觅良机。程智涵做球，包凯文调整角度后远距离抽射，皮球直奔左上死角，环境队门将韩立秦反应迅速，单掌将球击出横梁。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610120b35132923bf8de3b3d.png" style = "with:380px; height:214px"></img></p>
<p>宜将剩勇追穷寇，第16分钟，程智涵中场一路带球突破，郑家浩犯规，地海获得任意球机会。程智涵短暂观察后直接攻门，皮球绕过人墙，划出一道美丽的弧线直窜右下死角，2-0，地海扩大领先优势。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610120b45132923bf8de3da8.png" style = "with:380px; height:214px"></img></p>
<p>你方唱罢我登场，第22分钟，刘嘉航禁区内手球，环境队获得点球机会。陈泓宇主罚骗过门将，环境扳回一球，地海2-1环境。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610120b25132923bf8de37bf.png" style = "with:380px; height:214px"></img></p>
<h3 id="上半场伤停补时阶段，"><a href="#上半场伤停补时阶段，" class="headerlink" title="上半场伤停补时阶段，"></a>上半场伤停补时阶段，</h3><p>地海持续发动攻势。34分钟，程智涵开出角球，刘嘉航后点头球攻门，环境队后卫解围后阿卜杜拉中场迎球抽射，皮球稍偏出界。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610120b35132923bf8de38e8.png" style = "with:380px; height:214px"></img></p>
<p>补时最后时刻，环境险些扳平比分。前场突破获得任意球机会，曲宏昌送出地面直塞，白玛朗杰转身摆脱时被金加盛踢倒，主裁再度判罚点球。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610120ff5132923bf8df39e6.png" style = "with:380px; height:214px"></img></p>
<p>陈泓宇再度站上点球点，地海换刘嘉航担任门将，后者机敏猜对方向，倒地将球扑出。</p>
<h2 id="下半场"><a href="#下半场" class="headerlink" title="下半场"></a>下半场</h2><p>下半场地海仍然率先掌握主动。第31分钟，程智涵得球后背身将球分给前插的包凯文，后者连突两人后攻门被防守队员挡出底线。</p>
<p>一波未平，一波又起。第35分钟，后场阿卜杜拉发动进攻，金加盛直塞找到包凯文，后者沿边线分球给艾山江，艾山江扣球后转身内切，吊射远角打偏。</p>
<p>你挥七星拳，我展八卦掌。第44分钟，环境终于再获良机。王纵横中场附近横传，白玛朗杰扣过两名防守队员后起脚抽射，门将反应及时将球扑出。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610120ff5132923bf8df39ff.png" style = "with:380px; height:214px"></img></p>
<p>第45分钟，地海用当家射手艾尔肯换下王禹洋。</p>
<p>吃一堑长一智。第48分钟，地海获得相同位置任意球，程智涵再度选择攻门。环境门将韩立秦吸取教训，封堵近角将球没收。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610121005132923bf8df3a11.png" style = "with:380px; height:214px"></img></p>
<p>第53分钟，艾尔肯恶意犯规吃到黄牌。随后其不满判罚，得到第二张黄牌被罚出场。</p>
<p>第59分钟，门将刘嘉航抽筋，程智涵临危受命站在门线前。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/610121005132923bf8df3a30.png" style = "with:380px; height:214px"></img></p>
<p>野火吹不尽，春风吹又生。伤停补时阶段，环境队并未放弃，阿卜杜拉解围失误，刘之言得球后果断打门，程智涵封死近角将球没收。</p>
<p>全场比赛结束，最终凭借程智涵的出色发挥，地海2-1击败环境闯入足协杯决赛。</p>
]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>足球比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>足协杯决赛</title>
    <url>/%E7%9B%B8%E5%86%8C/football-match-06-12/</url>
    <content><![CDATA[<h1 align = "center">夺冠啦</h1>
<h3 align = "center">地海 7:6 政管 (点球5：4)</h3>
北京时间6月13日20：00，南京大学2020/21赛季足协杯决赛在仙林校区四组团足球场打响，由地理与海洋科学学院迎战政府管理学院。不断的雨水并没有浇灭两队对夺冠的渴望，两队的球员顶着稍显恶劣的天气给我们送上了一场精彩绝伦的比赛。

<p><strong>比赛直播及回放：<a href="https://wechat.ingsoccer.com.cn/web/events/live/21979">https://wechat.ingsoccer.com.cn/web/events/live/21979</a></strong></p>
<p>**官方推文：<a href="https://mp.weixin.qq.com/s/Mz9V0swztRvJ8Ue60zZE2A">https://mp.weixin.qq.com/s/Mz9V0swztRvJ8Ue60zZE2A</a> **</p>
<p>上半场政管掌握比赛主动权，多次发动了有威胁的进攻，最终也由海尔打破僵局1：0领先。</p>
<p>下半场地海逐渐找到状态，地海球员程智涵牵动了大量的防守精力，并且找机会扳平了比分。随后政管球员阿布单骑救主，单人突破并破门。但地海展现出了顽强的韧劲，又一次把比分绝平至2：2。</p>
<p>在点球大战中，地海门将受伤，程智涵客串门将并扑出了两粒点球，以5：4的点球大站成绩带领球队赢得了胜利。</p>
<p>最终全场比赛结束，地海凭借顽强的精神和韧劲一次次扳平比分，最终拖入点球大战并赢得了胜利，勇夺足协杯冠军！</p>
<p>政管虽然战败，但同样打出了自己的态度和高昂的斗志，值得每一个人的尊重。</p>
<h2 id="首发阵容"><a href="#首发阵容" class="headerlink" title="首发阵容"></a>首发阵容</h2><p><img align = "center" src = "https://pic.imgdb.cn/item/61011d065132923bf8d07dee.png" style = "with:380px; height:214px"></img></p>
<p>赛况</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d065132923bf8d07e03.png" style = "with:380px; height:214px"></img></p>
<h2 id="关键事件"><a href="#关键事件" class="headerlink" title="关键事件"></a>关键事件</h2><h2 id="上半场"><a href="#上半场" class="headerlink" title="上半场"></a>上半场</h2><h3 id="开场1分钟，"><a href="#开场1分钟，" class="headerlink" title="开场1分钟，"></a>开场1分钟，</h3><p>政管球员杨旭带球向前推进，地海球员刘嘉航阻挡球员前进路线犯规，裁判直接出示黄牌。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d065132923bf8d07e1c.png" style = "with:380px; height:214px"></img></p>
<p>随后政管球员阿布开出贴地战术任意球，造成门前混战，政管球员海尔门前抓住机会捅射，可惜没有打上力量，球被地海门将王禹洋扑出。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d065132923bf8d07dbf.png" style = "with:380px; height:214px"></img></p>
<h3 id="比赛第10分钟，"><a href="#比赛第10分钟，" class="headerlink" title="比赛第10分钟，"></a>比赛第10分钟，</h3><p>地海获得角球机会，由程智涵开到中间，刘嘉航头球攻门，可惜在防守队员的干扰下，皮球高出球门。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d065132923bf8d07dd9.png" style = "with:380px; height:214px"></img></p>
<p>比赛第16分钟，地海球员程智涵在中圈附近试图抢断政管球员开迪时犯规，政管获得任意球机会。政管球员朱鸿森主罚并直接打门，但地海门将王禹洋不给机会，将球封堵了出去。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d665132923bf8d1e96b.png" style = "with:380px; height:214px"></img></p>
<h3 id="比赛第20分钟，"><a href="#比赛第20分钟，" class="headerlink" title="比赛第20分钟，"></a>比赛第20分钟，</h3><p>地海球员程智涵接到后场的长传球后，在底线连过两人并起脚打门，但被政管门将朱天昊封死了路线。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d665132923bf8d1e98e.png" style = "with:380px; height:214px"></img></p>
<p>地海因此获得角球机会，由程智涵开到中间，艾山江抓住机会抬脚垫射，可惜角度稍正，被门将朱天昊直接挡出。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d675132923bf8d1ee23.png" style = "with:380px; height:214px"></img></p>
<p>比赛第22分钟，地海球员后场传球失误，被政管球员海尔截断，随后海尔稍作调整，起脚用外脚背远射，皮球划出诡异弧线，骗过了地海门将王禹洋。政管1：0地海，打破了僵局！</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d675132923bf8d1ee5f.png" style = "with:380px; height:214px"></img></p>
<p>比赛第26分钟，政管球员海尔接到队友的边线球后顺势用外脚背从左路传中，阿布前点头球攻门，可惜皮球从左侧偏出球门。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011d665132923bf8d1e945.png" style = "with:380px; height:214px"></img></p>
<p>比赛第28分钟，政管球员阿布接到海尔的传球，稍作调整之后起脚远射，皮球直飞球门左上角，但地海门将王禹洋注意力很集中，快速反应扑出了这一脚质量比较高的远射。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011da65132923bf8d2e34d.png" style = "with:380px; height:214px"></img></p>
<h2 id="下半场。"><a href="#下半场。" class="headerlink" title="下半场。"></a>下半场。</h2><p>地海在下半场第6分钟获得任意球机会，由10号包凯文主罚，包凯文选择直接打门，打出了一记精彩的电梯球，可惜最终皮球稍稍高出横梁。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011da75132923bf8d2e719.png" style = "with:380px; height:214px"></img></p>
<h3 id="下半场第9分钟，"><a href="#下半场第9分钟，" class="headerlink" title="下半场第9分钟，"></a>下半场第9分钟，</h3><p>地海球员程智涵前场带球，被杨旭在防守时绊倒，造成了政管的犯规。裁判给杨旭出示了黄牌以警告。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011da75132923bf8d2e742.png" style = "with:380px; height:214px"></img></p>
<p>下半场第12分钟，地海获得前场的边线球机会，程智涵在混乱中抓住机会，左脚冷静推射，皮球直奔左下死角，政管门将反应不及，地海1：1政管扳平比分！</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011da65132923bf8d2e2c4.png" style = "with:380px; height:214px"></img></p>
<p>下半场第18分钟，政管球员阿布在中场完成抢断，身体对抗护住球后，向右内切横向拉开，摆脱了中后卫阿卜杜拉，随后反向起脚，向球门左侧劲射破门。政管2：1地海再次领先！</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011da65132923bf8d2e30c.png" style = "with:380px; height:214px"></img></p>
<h3 id="下半场第20分钟，"><a href="#下半场第20分钟，" class="headerlink" title="下半场第20分钟，"></a>下半场第20分钟，</h3><p>地海获得角球的机会，由程智涵开出贴地球，后点艾山江抢到射门机会可惜艾山江没有将射门姿势调整到位，将球打高了。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e135132923bf8d4815b.png" style = "with:380px; height:214px"></img></p>
<p>下半场第23分钟，地海球员程智涵带球向前推进，给了政管球员很大压力，牵动了政管整条防线，最后他横传包凯文，包凯文抬脚劲射，可惜皮球稍稍从右侧偏出。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e135132923bf8d48176.png" style = "with:380px; height:214px"></img></p>
<p>因此地海获得角球机会，程智涵将球开到中间，艾江山抢点推射造成穆萨乌龙，地海2：2在最后5分钟绝平比分！</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e145132923bf8d483d5.png" style = "with:380px; height:214px"></img></p>
<p>比赛第27分钟，地海球员叶斯布拉提替补登场换下石弘阳。</p>
<h3 id="比赛进入伤停补时，"><a href="#比赛进入伤停补时，" class="headerlink" title="比赛进入伤停补时，"></a>比赛进入伤停补时，</h3><p>地海替补球员毕皓换下门将王禹洋，门将由刘嘉航出任。</p>
<h2 id="点球大战"><a href="#点球大战" class="headerlink" title="点球大战"></a>点球大战</h2><p>至此常规比赛时间结束，比赛将进入残酷的点球大战。</p>
<p>第一球由地海球员程智涵主罚，势大力沉地将球打向了左下角，守门员反应不及，皮球应声入网。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e155132923bf8d48753.png" style = "with:380px; height:214px"></img></p>
<p>第二球由政管球员阿布主罚，同样是势大力沉的左侧球，超高的球速让门将无能为力。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e135132923bf8d48135.png" style = "with:380px; height:214px"></img></p>
<p>但在这次扑救的时候产生了意外情况，刚刚更换的地海门将刘嘉航腿部严重受伤，无法坚持进行比赛。根据规则，由8号程智涵客串门将继续进行接下来的点球大战。</p>
<p>第三球由地海球员包凯文主罚，大力将球射向右侧的同时骗过了门将，将球打进。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e795132923bf8d61056.png" style = "with:380px; height:214px"></img></p>
<p>第四球由政管球员开迪主罚，临危受命的程智涵状态神勇，直接扑出了发向球门右侧的点球！</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e7a5132923bf8d613c5.png" style = "with:380px; height:214px"></img></p>
<p>第五球由地海球员毕皓主罚，门将虽然判断对了左侧这一方向，可也只能望球兴叹。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e7a5132923bf8d613fb.png" style = "with:380px; height:214px"></img></p>
<p>第六球由政管球员杨旭主罚，皮球擦着门将的指尖入网。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e795132923bf8d6100e.png" style = "with:380px; height:214px"></img></p>
<p>第七球由地海球员阿卜杜拉主罚，将球发向了球门正中心，虽然球速不慢但角度稍正，球被门将朱天昊无情拒绝。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011e795132923bf8d61021.png" style = "with:380px; height:214px"></img></p>
<p>第八球由政管球员穆萨主罚，门将反应不及，只能让球入网。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011edd5132923bf8d76e7c.png" style = "with:380px; height:214px"></img></p>
<p>第九球由地海球员艾江山主罚，皮球精准射入了左下角。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011edd5132923bf8d7718c.png" style = "with:380px; height:214px"></img></p>
<p>第十球由政管球员海尔主罚，轻松晃过门将将球送入右下角。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011edd5132923bf8d771b4.png" style = "with:380px; height:214px"></img></p>
<p>第十一球由刚刚因受伤被换下的地海门将刘嘉航主罚，同样轻巧的骗过门将，将球推送入右下角。</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011edd5132923bf8d76e50.png" style = "with:380px; height:214px"></img></p>
<p>第12球由政管球员朱鸿森主罚，但客串门将的程智涵不给机会，干净利落地将球扑出！</p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011edd5132923bf8d76e64.png" style = "with:380px; height:214px"></img></p>
<h2 id="决出胜负"><a href="#决出胜负" class="headerlink" title="决出胜负"></a>决出胜负</h2><p><strong>至此让我们恭喜地海赢得了这一场点球大战，也赢得了这一届足协杯的冠军！</strong></p>
<p><img align = "center" src = "https://pic.imgdb.cn/item/61011f3d5132923bf8d8c1fa.png" style = "with:380px; height:214px"></img></p>
]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>足球比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>足协杯夺冠照片</title>
    <url>/%E7%9B%B8%E5%86%8C/football-match-06-15/</url>
    <content><![CDATA[<h1 align = "center">足协杯夺冠照片</h1>



<table>
      <tr> 
          <td align = "center"><img src="https://pic.imgdb.cn/item/610118a75132923bf8b719e9.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/610118a75132923bf8b719a9.jpg" style = "width:380px; height:214px" border=0></td> 
      </tr>
      <tr> 
          <td align = "center"><img src="https://pic.imgdb.cn/item/610119385132923bf8bba2a6.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/610119385132923bf8bba2d0.jpg" style = "width:380px; height:214px" border=0></td> 
      </tr>
            <tr> 
          <td align = "center"><img align = "center" src="https://pic.imgdb.cn/item/610119385132923bf8bba2f7.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/6103cd4f5132923bf8458a5c.jpg" style = "width:380px; height:214px" border=0></td> 
      </tr>
</table>  


]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>足球比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记</title>
    <url>/%E7%AC%94%E8%AE%B0/git-learning/</url>
    <content><![CDATA[<p>记录 Git 的一些常用指令与问题解决方案。</p>
<p>更加具体的内容请看以下仓库：</p>
<ul>
<li><a href="https://github.com/payiz-asj/git-tips">Git 的奇技淫巧</a></li>
<li><a href="https://github.com/payiz-asj/HelloGitHub">GitHub 上有趣、入门级的开源项目</a></li>
</ul>
<span id="more"></span>


<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h3><ul>
<li>从远程仓库获取线上代码: <code>git clone git@github.com:用户名/项目名.git</code></li>
<li>关联远程仓库: <code>git remote add origin git@github.com:xxx/xxx.git</code> (git clone 后已自动关联)</li>
<li>git 拉取代码更新项目: <code>git pull origin master</code></li>
</ul>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li><p>删除远程仓库地址： <code>git remote rm origin</code></p>
</li>
<li><p>增加远程仓库地址： <code>git remote add origin git@github.com:xxx/xxx.git</code> or <code>git remote add origin https://github.com/xxx/xxx</code> ( origin 为远程仓库命名)</p>
</li>
<li><p>查看远程库信息： <code>git remote -v</code></p>
</li>
<li><p>关联多个远程仓库:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:xxx/xxx.git</span><br><span class="line">git remote add gitee git@gitee.com:xxx/xxx.git</span><br><span class="line">git remote add coding git@git.coding.net:xxx/xxx.git</span><br></pre></td></tr></table></figure>

<h3 id="代码推送"><a href="#代码推送" class="headerlink" title="代码推送"></a>代码推送</h3><ul>
<li><p>git 初始化： <code>git init</code></p>
</li>
<li><p>保存到暂存区： <code>git add -A</code>   (git 2.0以后<code>git add -A</code>与<code>git add .</code>功能相同 )</p>
</li>
<li><p>输入描述信息并提交到本地的 Git： <code>git commit -m &quot;Say something&quot;</code></p>
</li>
<li><p>修改已经提交的描述： <code>git commit --amend</code> <a href="#%E4%BF%AE%E6%94%B9%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%86%85%E5%AE%B9">修改已提交内容</a></p>
</li>
<li><p>将代码推送到 GitHub： <code>git push</code> or <code>git push -u origin master</code> ( <code>-u</code> 选项指定一个默认主机,后面就可以不加任何参数使用 <code>git push</code> )</p>
</li>
<li><p>强制推送： <code>git push -u origin master -f</code></p>
</li>
<li><p><a href="#git-push-%E8%AF%A6%E8%A7%A3">git push 详解</a></p>
</li>
<li><p>清空文件夹的本地缓存: <code>git rm -r --cached </code></p>
</li>
</ul>
<h3 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h3><p>在 Git 中，用 HEAD 表示当前版本，，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成 HEAD~100。</p>
<p><code>--hard</code> 会包括当前源码回到上次状态。</p>
<p>保留当前更改，只回退 commit 信息可使用 <code>--soft</code>。</p>
<p>清除缓存区中准备提交的内容，只保留修改的状态，可不加参数，或使用 <code>--mixed</code>。</p>
<ul>
<li><p>回滚到上一版本：<code>git reset --hard HEAD^</code></p>
</li>
<li><p>回退到指定版本 <code>git reset --hard id</code> (id 为 commit 版本号，填写前数位保证不重复即可)</p>
</li>
<li><p>通过 <code>git log</code> 查看历史版本</p>
</li>
</ul>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul>
<li><p>显示当前分支 <code>git branch -v</code></p>
</li>
<li><p>显示远程分支 <code>git remote -v</code></p>
</li>
<li><p>将当前分支切换到 master 分支上: <code>git checkout master</code></p>
</li>
<li><p>创建一个名为 xxx 的新分支: <code>git checkout -b xxx</code> , <code>-b</code> 选项表示创建指定名称的新分支。</p>
</li>
<li><p>新建远程分支： <code>git push origin 推送的分支:远程的分支</code></p>
</li>
<li><p>合并分支： <code>git merge fake-branch</code></p>
</li>
<li><p>删除分支： <code>git branch -d fake-branch</code></p>
</li>
<li><p>删除远程分支：<code>git push origin –-delete 分支名</code></p>
</li>
<li><p>修改分支名称：<code>git branch -m old_branch_name new_branch_name</code></p>
</li>
</ul>
<h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><ul>
<li><p><code>git rm --cached [文件路径]</code></p>
</li>
<li><p><code>-r</code> 递归</p>
</li>
<li><p><code>-f</code> 强制</p>
</li>
</ul>
<p>Example: <code>git rm -r --cached .</code></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>比赛回忆</title>
    <url>/Hackathon%E5%8D%8E%E4%B8%9C%E4%B9%9D%E6%A0%A1%E7%BC%96%E7%A8%8B%E5%88%9B%E5%AE%A2%E9%A9%AC%E6%8B%89%E6%9D%BE/hackathon-memory/</url>
    <content><![CDATA[<h1 align = "center">Hackathon编程马拉松项目</h1>
<h3 align = "center">——微信小程序“送信鸭”</h3>
<p>
    <img align ="center" src = "https://pic.imgdb.cn/item/60fe7e585132923bf8be7495.png" style = "width:81px"/>
</p>



<p>这周末参加了一个很有意思的编程比赛，想写篇文章记录一下比赛经历。 </p>
<span id="more"></span>



<h3 id="赛事信息："><a href="#赛事信息：" class="headerlink" title="赛事信息："></a>赛事信息：</h3><p>​        南京大学和微软亚洲研究院主办、由微软开发者关系部门、东南大学、南京航空航天大学、南京理工大学、苏州大学、山东大学、同济大学和华东师范大学，复旦大学联合承办的创客马拉松大赛 “Hackathon 华东 2020” 。</p>
<p>​        比赛形式：1-4人组成一个队伍，各高校之间可以互相组队，在24小时连续编程。</p>
<p><strong>比赛官网：</strong> <a href="https://hackathon2020eastchina.top/">https://hackathon2020eastchina.top/</a></p>
<h3 id="我们的队伍"><a href="#我们的队伍" class="headerlink" title="我们的队伍"></a>我们的队伍</h3><p><strong>队伍名：</strong>“觉醒吧，猎杀时刻！”</p>
<p><strong>作品名称：</strong>微信小程序“送信鸭” </p>
<p><strong>队伍成员：</strong> 艾山江（队长）、郭庭、阿卜杜拉、艾尔肯</p>
<p><strong>队伍成果：</strong>我们队在24小时几乎一直没有休息，最终完成了微信小程序“送信鸭”的需求分析及部分前后端功能实现，答辩时得到评委认可，最终排名9/28。 </p>
<h3 id="作品介绍："><a href="#作品介绍：" class="headerlink" title="作品介绍："></a>作品介绍：</h3><p>​    我们观察到2020疫情期间学校宿舍后管理室在分发学生信件、明信片等资料工作中的众多困难，准备做一个小程序来解决问题。与此同时，我们发现了此小程序在陌生人交友、青年社区等潜力，大家励志想打造一款可以<strong>邮寄、寄收实体信件、电子信件</strong>等，又包含<strong>陌生人写信社交、树洞分享故事、青年社区等精彩版块</strong>的微信小程序。</p>
<p>​    您可以在这里给<strong>现实中的朋友邮寄实体信件、明信片等</strong>，并<strong>监控信件的分发路程</strong>，还可以<strong>查询自己待收取、收取记录</strong>；您<strong>还可以</strong>在这里给好友<strong>写电子信件、明信片、生日贺卡等</strong>，<strong>还可以倾诉故事，认识新的朋友</strong>。</p>
<p>​    期待您的加入！</p>
<h3 id="创意来源"><a href="#创意来源" class="headerlink" title="创意来源"></a>创意来源</h3><p>​        宿舍楼管理室宿管阿姨叫我们队员中的一位同学帮忙送一下学生的信件和明信片，一共有30多件，他花了2个小时将其中的17件送到了对应的学生宿舍，剩下那么多都是半年前，甚至一年前的信件，他到收信人宿舍发现已经换了新生。。。<br>​    有些信件上面除了<strong>学生宿舍号</strong>，还有<strong>电话号码</strong>，他打通了几个电话，对方有些人表示<strong>因为疫情原因，很长时间没开学这个信件一直没能过来取，还有一些人表示才知道自己有这么一封信！</strong><br>​    我们宿舍楼的学生信件其实已经放到很显眼的位置了，就在宿管阿姨值班的窗口那里，学生可以随时过去领自己的信件，如果寄信也可到窗口委托阿姨寄信。那为什么有那么多信件没人来领，而且在阿姨那里放了那么久呢？<br>​    <strong>这件事激发了我们的关注，大家一致同意在这次黑客松编程马拉松的比赛中，利用自己的技术帮助宿管阿姨们解决困难。</strong><br>​    对此事进行了深入调研发现，我们宿舍楼的信箱里，有大概几种类型的信件：来自好友的信件、明信片及贺卡，书店邮寄的书本及杂志，银行贷款账单，有些合同等。<br>​    信件封面一般都会标有收信<strong>姓名、地址（具体到宿舍号）、电话号</strong>等，<strong>个别还有寄信日期</strong>   ，正好这些信息可以利用我们的技术手段给同学们和宿管阿姨们提供便利的信件查询服务，还可以提供更加高效的寄信服务。</p>
<p>​    再进行了<strong>充分的需求分析</strong>后，我们查找素材、做LOGO、 设计界面、编写后端交互，并且在仅有的24小时中已经完成了部分前端界面和后端功能的开发。</p>
<h3 id="作品预览："><a href="#作品预览：" class="headerlink" title="作品预览："></a>作品预览：</h3><p>
    <img align ="center" src = "https://pic.imgdb.cn/item/60fe7eb35132923bf8bfc0a8.png"/>
    <h3 align ="center">作品预览.png</h3>
</p>    

<h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h3><p>​    仓库地址：<a href="https://github.com/juexingle">https://github.com/juexingle</a> </p>
<p>​    说明：在比赛公示期结束后本仓库将会设置<strong>private</strong> 权限。</p>
<h3 id="关于版权信息"><a href="#关于版权信息" class="headerlink" title="关于版权信息"></a>关于版权信息</h3><p>​    本项目属于Hackathon 2020参赛队伍 “觉醒吧，猎杀时刻！” 参赛作品及原创微信小程序，欢迎大家前来体验和提出建议，请勿用于商业用途。谢谢！</p>
]]></content>
      <categories>
        <category>Hackathon华东九校编程创客马拉松</category>
      </categories>
      <tags>
        <tag>个人项目</tag>
      </tags>
  </entry>
  <entry>
    <title>项目需求分析</title>
    <url>/Hackathon%E5%8D%8E%E4%B8%9C%E4%B9%9D%E6%A0%A1%E7%BC%96%E7%A8%8B%E5%88%9B%E5%AE%A2%E9%A9%AC%E6%8B%89%E6%9D%BE/hackathon-requirement-analysis/</url>
    <content><![CDATA[<h2 align = "center">——“送信鸭”小程序</h2>
## 1. 需求获取 / 需求调研：

<h3 id="1-1-访谈"><a href="#1-1-访谈" class="headerlink" title="1.1 访谈"></a>1.1 访谈</h3><p>​    通过访谈获取需求是需求获取方法中最直接、最快速的一种方法了，往往能够<strong>最直接、最具体、清晰、客观地</strong>了解目标用户的需求。   </p>
<span id="more"></span>



<h4 id="1-1-1-用户访谈"><a href="#1-1-1-用户访谈" class="headerlink" title="1.1.1 用户访谈"></a>1.1.1 用户访谈</h4><p>​    我们首先来到学校宿舍楼01栋值班室，与值班的阿姨们聊天，对她们进行了访谈，因为他们是这个项目的目标用户之一，而且这个项目立项也是受她们启发。<br>​    我们利用大约一个小时的访谈，获取了以下11条需求：   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 希望能够有效地分发值班室收到的信件</span><br><span class="line"><span class="number">2.</span> 需要能够方便管理寄信，寄明信片流程</span><br><span class="line"><span class="number">3.</span> 需要有一定的隐蔽性，学生的姓名、学号呀、手机号啊之类的信息不能泄露</span><br><span class="line"><span class="number">4.</span> 平台最好是手机APP或者小程序，其他的东西我们学不会</span><br><span class="line"><span class="number">5.</span> 学校宿舍管理人员是否有特殊的身份可以进行普通用户以外的功能？</span><br><span class="line"><span class="number">6.</span> 不要频繁更新</span><br><span class="line"><span class="number">7.</span> 有使用说明，或者良好的导航栏，容易上手</span><br><span class="line"><span class="number">8.</span> APP体积不要太大，手机内存吃不消</span><br><span class="line"><span class="number">9.</span> 字体能够调整，界面颜色也能调整就更好啦</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-开发人员访谈"><a href="#1-1-2-开发人员访谈" class="headerlink" title="1.1.2 开发人员访谈"></a>1.1.2 开发人员访谈</h4><p>​    用户访谈往往只能获取一些表面化的功能性需求，而开发人员访谈能够获得比<strong>较全面、明确、技术化</strong>的需求。<br>​    因此我们进行了一次开发人员访谈，因为时间有限，我们就只采用了队内开发人员充当不同领域的开发人员进行模拟访谈。包括以下角色：<br>​        艾山江（队长）：访谈人、记录人员<br>​        郭庭：被访谈人，前端工程师<br>​        艾尔肯：被访谈人，后端工程师<br>​        阿卜杜拉：被访谈人，测试工程师   </p>
<p>​    经过半个小时的访谈及讨论，又得到了以下需求：   </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 界面优雅、操作易懂、不含广告</span><br><span class="line"><span class="number">2.</span> 考虑到目标用户、市场、跨平台性(不考虑Linux)，最好是开发一个微信小程序</span><br><span class="line"><span class="number">3.</span> 相应速度必须快，软件包不能太大，代码易于重构迭代，版本控制</span><br><span class="line"><span class="number">4.</span> 后端数据需要清晰、高效率的数据库，并考虑部分数据采取保密措施</span><br><span class="line"><span class="number">5.</span> 需要收集使用情况、崩溃报告信息、用户主动反馈消息</span><br><span class="line"><span class="number">6.</span> 输入框提供良好的编辑操作</span><br><span class="line"><span class="number">7.</span> 文字的可复制性</span><br><span class="line"><span class="number">8.</span> 查询功能的范围-&gt;信件标题||内容,全局搜索</span><br><span class="line"><span class="number">9.</span> 页面跳转逻辑合理</span><br><span class="line"><span class="number">10.</span> 具有最低硬件环境要求，并检测不符合的硬件给出提示</span><br><span class="line"><span class="number">11.</span> 利用github进行本本管理</span><br><span class="line"><span class="number">12.</span> 对用户输入进行检测和反馈，提高鲁棒性</span><br><span class="line"><span class="number">13.</span> 搜索栏、查询功能需要防止SQL注入、渗透测试等黑客攻击</span><br><span class="line"><span class="number">14.</span> 能够预防CDN攻击、DDOS攻击及一切黑客攻击手段</span><br><span class="line"><span class="number">15.</span> 产品的推广能力需要强一点</span><br><span class="line"><span class="number">16.</span> 适当提供用户个性化定制操作（包括设置、图样、文字、消息推送等）</span><br></pre></td></tr></table></figure>
<h3 id="1-2-市场调研-同类产品的需求文档"><a href="#1-2-市场调研-同类产品的需求文档" class="headerlink" title="1.2 市场调研 / 同类产品的需求文档"></a>1.2 市场调研 / 同类产品的需求文档</h3><p>​    市场调研的优点在于数据的<strong>真实性、时效性</strong>，能够根据市场的现状得到<strong>真实、最新的需求</strong>。<br>​    然而，我们的“送信鸭”这个产品属于创新项目、市场上没有与之直接对应的已有产品做参考。但是，将我们把“送信鸭”的服务内容拆开为“物流”和“社交”两个方面以后就有很多已有的产品做参考了！<br>​    目前各个小程序寄主平台(微信、QQ、支付宝、头条、百度)，对于小程序还没有出现评分、评论体系，因此，我们退而求次，准备通过类似产品，即移动应用（APP）的评分、评论得到市场上关于我们这个产品的需求。<br>​    我们选取了以下三个APP进行分析：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">《邮政EMS》 ：典型信件物流      </span><br><span class="line">《给未来写封信》：典型信件树洞      </span><br><span class="line">《过客 Gorkor 》：典型信件社交      </span><br></pre></td></tr></table></figure>
<p>​    考虑到这些APP的技术团队没有（<strong>不太会</strong>）提供他们开发时的需求文档，所以我们准备利用爬虫技术爬取这些APP的用户评论数据，从用户评论里得到用户需求。  </p>
<p>​    选择评论数据来源：<strong>华为应用市场</strong>（国内市场用户量最大的安卓应用商店）   </p>
<h4 id="1-2-1-具体过程"><a href="#1-2-1-具体过程" class="headerlink" title="1.2.1 具体过程"></a>1.2.1 具体过程</h4><p>​    由艾山江独立写python代码完成此部分工作。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 爬取数据：写python代码爬虫，爬取结果用pandas库写入csv文件。  </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 提取目标数据段:从评论数据（评论人，评分星级、评论时间、APP版本号、用户机型、评论内容）中，分理出“评分星级”和“评论内容”。  </span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 清洗数据：  </span><br><span class="line">​	<span class="number">2.1</span> 初步清洗 ：过滤重复内容以及评论字数小于<span class="number">7</span>的评论   </span><br><span class="line">​	<span class="number">2.2</span> 深度过滤 ：</span><br><span class="line">		<span class="number">2.2</span><span class="number">.1</span> 利用“语气词词库”、“暴力、涉政、敏感词词库”等词库进行匹配、过滤；  </span><br><span class="line">​	    <span class="number">2.2</span><span class="number">.2</span> 利用NLP技术对评论内容进行情感极性分析、内容识别、文本分类，以便过滤掉无关、广告、舆情等不良评论。（这次比赛因时间太短，训练数据集来不及，因而此项暂未被启用）  </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 词频统计：利用stylecloud(wordcloud的扩展)库进行词频统计并输出词云，结果如下图<span class="number">1</span>-<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="1-2-1-调研结果"><a href="#1-2-1-调研结果" class="headerlink" title="1.2.1 调研结果"></a>1.2.1 调研结果</h4><p>​        需求调研结果用词云来表示如下:</p>
<p>
    <img align ="center" src = "https://pic.imgdb.cn/item/6101bdae5132923bf8da73c2.jpg"/>
    <p align ="center">图 1-1</p>
</p>        

<p>​        因为时间太紧张，有些语气词没能完全过滤率掉，导致真正的关于功能的需求频率太小图片里看不清。<br>​        经过查看本地词频统计结果(结果.txt)，我们又大致得到了一下需求及需要考虑的问题：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 收不到验证码，一直都没有办法注册</span><br><span class="line"><span class="number">2.</span> 良心社区，笔友素质高，</span><br><span class="line"><span class="number">3.</span> 界面简洁，色调舒服</span><br><span class="line"><span class="number">4.</span> 想要那种只自己一个人说话一个人看的私密空间</span><br><span class="line"><span class="number">5.</span> 总说登录过期啦？明明一天时间都没有到</span><br><span class="line"><span class="number">6.</span> 纷扰的世界里少有的宁静，心甘情愿氪金（我们觉得应该是合理的商业化指向，即不要盲目收费，先搞好社区气氛，再适当地提供有偿的精美道具、模板之类的内部商品）</span><br><span class="line"><span class="number">7.</span> 客服对线和管理的水平令人不适！</span><br><span class="line"><span class="number">8.</span> 每次登录都要验证码 麻烦了;希望什么时候可以加一个密码登录。</span><br><span class="line"><span class="number">9.</span> 可以帮笔友买邮票吗？买邮票的地方有个选项是为谁购买;可是选了笔友的名字买了以后还在我这？？</span><br><span class="line"><span class="number">10.</span> 收到这信的时候; 还活着。三年时间了</span><br><span class="line"><span class="number">11.</span> 如果能选具体的收信时间更好(这个需求超级棒，这样可以定制生日礼物明信片！当天送达！这也可以是一个新的商业化价值)</span><br><span class="line"><span class="number">12.</span> 商城买的快递拒收后返运堪称蜗牛速度。客服都问不了;投诉不了;故意逃避责任？以后商城再给 发EMS 就不买华为了！！</span><br><span class="line"><span class="number">13.</span> 所谓的官方快递;包装如此简陋；看看顺丰;请正视差距;</span><br><span class="line"><span class="number">14.</span> 一点击“网点查询”就闪退</span><br><span class="line"><span class="number">15.</span> 没人来收;就显示已揽收，无奈！！！</span><br><span class="line"><span class="number">16.</span> 新用户还可以获得十元红包？！！哇</span><br><span class="line"><span class="number">17.</span> 本根点不开寄件</span><br><span class="line"><span class="number">18.</span> 四天前寄出的东西到 还查不到物流信息; 也是醉了-_-</span><br><span class="line"><span class="number">19.</span> ...</span><br><span class="line"><span class="number">20.</span> 一共<span class="number">9277</span>条</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    数量及其庞大！！但是需求分类可以解决这个问题。</p>
<h2 id="2-需求分类及优先级评定："><a href="#2-需求分类及优先级评定：" class="headerlink" title="2. 需求分类及优先级评定："></a>2. 需求分类及优先级评定：</h2><p>​    为了更精确地简化需求，我们进行了需求分类和优先级评定。因为本次比赛时间紧迫，所以我们对上述访谈和市场调研结果，挑选出了比较重要的需求，并参考国内软件需求分析人员常用的几个需求分类和等级分类，进行队内投票计算平均值的方式得到了本次项目的最终需求及需求优先级。<br>​    结果如下图1-2：</p>
<p>
    <img align ="center" src = "https://pic.imgdb.cn/item/6101be215132923bf8db1033.png"/>
    <p align ="center">图 1-2</p>
</p>

<h2 id="3-未来要完成的工作"><a href="#3-未来要完成的工作" class="headerlink" title="3. 未来要完成的工作"></a>3. 未来要完成的工作</h2><p>​    获得了我们本次项目的需求以后，接下来可以进行：<br>​        * 需求开发：建模、撰写需求文档<br>​        * 需求管理：升级、维护<br>​        * 这些是以后的事儿啦，我们现在时间有限，就直接按照上面的需求，开始写代码吧！💪💪   </p>
<p>​        </p>
]]></content>
      <categories>
        <category>Hackathon华东九校编程创客马拉松</category>
      </categories>
      <tags>
        <tag>个人项目</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 东京奥运会</title>
    <url>/%E5%A5%A5%E8%BF%90%E4%BC%9A/olympic/</url>
    <content><![CDATA[<h1 align="center">中国加油 💪</h1>

<img align="center" src="https://pic.imgdb.cn/item/6103c3dd5132923bf82857f0.png" >

<p><strong>网页链接：</strong>     <a href="https://tiyu.baidu.com/tokyoly/home/tab/%E8%B5%9B%E7%A8%8B/type/hot">赛程</a>                                      <a href="https://tiyu.baidu.com/tokyoly/home/tab/%E5%A5%96%E7%89%8C%E6%A6%9C">奖牌榜</a>                                 <a href="https://tiyu.baidu.com/tokyoly/home/tab/%E5%A5%A5%E8%BF%90%E9%A1%B9%E7%9B%AE">奥运项目</a>                                   <a href="https://tiyu.baidu.com/tokyoly/home/tab/%E6%96%B0%E9%97%BB">新闻</a></p>
<p><strong>直播地址：</strong><a href="https://www.miguvideo.com/mgs/website/prd/sportsHomePage.html">咪咕视频-东京奥运会</a></p>
<h2 id="关注奥运会，支持祖国！💖"><a href="#关注奥运会，支持祖国！💖" class="headerlink" title="关注奥运会，支持祖国！💖"></a>关注奥运会，支持祖国！💖</h2>]]></content>
      <categories>
        <category>奥运会</category>
      </categories>
      <tags>
        <tag>奥运会</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-1</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-1/</url>
    <content><![CDATA[<h1 id="软件测试基础理论"><a href="#软件测试基础理论" class="headerlink" title="软件测试基础理论"></a><strong>软件测试基础理论</strong></h1><h1 id="软件概念"><a href="#软件概念" class="headerlink" title="软件概念"></a>软件概念</h1><p>软件（Software）是一系列按照特定顺序组织的计算机数据和指令的集合。一般来讲，软件被划分为系统软件、应用软件和介于这两者之间的中间件。在国标中对软件的定义是与计算机系统操作有关的计算机程序、规程、规则以及可能有的文件、文档及数据等。</p>
<h1 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h1><p>生命周期（Life Cycle）的概念应用很广泛，简单说就是指一个对象的“生老病死”。对一个软件产品或软件系统而言也需要经历同样阶段，一般称为软件生命周期。软件生命周期大致分为六个阶段。</p>
<p><img src="https://pic.imgdb.cn/item/6100fd355132923bf846d6ea.jpg" alt="软件生命周期"></p>
<span id="more"></span>

<h2 id="项目计划阶段"><a href="#项目计划阶段" class="headerlink" title="项目计划阶段"></a>项目计划阶段</h2><p>此阶段主要是确定软件开发的总体目标，通过市场调研并给出功能、性能、接口等方面的设想以及项目的可行性分析，同时对项目开发使用的资源、成本、进度做出评估，制定项目实施的计划（项目一级计划）。</p>
<h2 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h2><p>需求俗称软件的主体，所以需求分析阶段作为一个非常重要的阶段，它由需求分析人员和用户共同对软件需要实现的各个功能进行详细的分析并给予确切的描述，并编写软件需求说明书（Software Requirements Specification，简称SRS）。</p>
<h2 id="软件设计阶段"><a href="#软件设计阶段" class="headerlink" title="软件设计阶段"></a>软件设计阶段</h2><p>该阶段俗称软件的核心，主要是由系统分析组（架构师和系统分析人员）根据需求分析的结果，对整个软件进行系统架构的设计，编写概要设计说明书（High Level Design，简称HLD）。接下来由数据库设计员和开发人员根据需求说明书和概要设计说明书进行系统数据库设计以及编写详细设计说明书（Low LevelDesign，简称LLD）。</p>
<h2 id="程序编码阶段"><a href="#程序编码阶段" class="headerlink" title="程序编码阶段"></a>程序编码阶段</h2><p>把软件设计的结果转换为计算机可运行的程序代码，使用RDBMS工具建立数据库。程序编码必须符合标准和编码规范，以保证程序的可读性、易维护性，保证程序运行的效率。</p>
<h2 id="软件测试阶段"><a href="#软件测试阶段" class="headerlink" title="软件测试阶段"></a>软件测试阶段</h2><p>此阶段主要是测试人员来检测软件是否符合客户的需求，是否达到质量的要求。一般在软件设计完成后，项目开发人员构建测试版本，以便测试团队进行测试，整个测试过程大致分为：单元测试、集成测试、系统测试、验收测试。</p>
<h2 id="运行与维护阶段"><a href="#运行与维护阶段" class="headerlink" title="运行与维护阶段"></a>运行与维护阶段</h2><p>此阶段是软件生命周期中最长的阶段。在软件开发完成并正式投入使用后，可能有很多原因需要对软件进行修改，如软件错误、系统升级、增加功能、提高性能等。</p>
<h1 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h1><h2 id="什么是C-S结构"><a href="#什么是C-S结构" class="headerlink" title="什么是C/S结构"></a>什么是C/S结构</h2><p>C/S（Client/Server）结构即客户端/服务器结构。客户端通常可以理解为安装在PC、手机终端设备上的软件，是软件系统体系结构的一种。比如：QQ软件、手机APP等，C/S模式简单地讲就是基于企业内部网络的应用系统。与B/S（Browser/Server，浏览器/服务器）模式相比，C/S模式的应用系统最大的好处是不依赖企业外网环境，即无论企业是否能够上网，都不影响应用。</p>
<p>还有一类通信的软件，比如：百度云盘、迅雷下载等，也属于C/S结构。但是它们之间的数据传输不需要经过服务器处理业务，可以直接通过客户端进行传输，这种结构通常称为P2P（Peer to Peer）点对点结构。</p>
<p>P2P是可以简单的定义成通过直接交换来共享计算机资源和服务，而对等计算模型应用层形成的网络通常称为对等网络。对等网络，即对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式。</p>
<h2 id="什么是B-S结构"><a href="#什么是B-S结构" class="headerlink" title="什么是B/S结构"></a>什么是B/S结构</h2><p>B/S（Brower/Server）结构即浏览器/服务器结构。随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户工作界面是通过浏览器来实现，极少部分事务通过逻辑在前端（Browser）实现，但是主要事务逻辑在服务器端（Server）实现，形成所谓三层3-tier结构。B/S是目前互联网中应用最为广泛的系统结构。B/S结构比起C/S结构有着很大的优越性，传统的MIS系统依赖于专门的操作环境，这意味着操作者的活动空间受到极大限制；而B/S结构则不需要专门的操作环境，在任何地方，只要能上网，就能够操作MIS系统，这其中的优劣差别是不言而喻的。</p>
<h1 id="软件测试基本概念"><a href="#软件测试基本概念" class="headerlink" title="软件测试基本概念"></a>软件测试基本概念</h1><p>测试（Test）就是为检测特定的目标是否符合标准而采用专用的工具或者方法进行验证，并最终得出特定的结果。软件测试（Software Testing）伴随着软件的诞生而产生。对软件而言，软件测试就是在有限的时间内提高软件质量的保证，是软件开发过程中非常重要的一部分。</p>
<h2 id="软件测试发展"><a href="#软件测试发展" class="headerlink" title="软件测试发展"></a>软件测试发展</h2><p>迄今为止，软件测试的发展一共经历了五个重要时期：</p>
<h3 id="以调试为主"><a href="#以调试为主" class="headerlink" title="以调试为主"></a>以调试为主</h3><p>早在20世纪50年代，计算机刚诞生不久，只有科学家级别的人才会去编程，需求和程序本身也远远没有现在这么复杂多变，相当于编程人员承担需求分析、设计、开发、测试等所有工作，当然也不会有人去区分调试和测试。然而有些比较严谨的科学家们已经在开始思考“怎么知道程序满足了需求？”这类问题了。</p>
<h3 id="以证明为主"><a href="#以证明为主" class="headerlink" title="以证明为主"></a>以证明为主</h3><p>在1957年，在《软件测试发展》（作者Charles Baker）一书中强调了调试和测试区分：1）调试（Debug），确保程序做了程序员想让它做的事情。</p>
<p>2）测试（Testing），确保程序解决了它该解决的问题。</p>
<p>这也是软件测试史上一个重要的里程碑，它标志软件测试终于自立门户了。随着计算机应用的数量，成本和复杂性都大幅度提升，其经济风险也大大增加，测试就显得很有必要了，这个时期测试的主要目就是确认软件是满足需求的，也就是我们常说的“做了该做的事情”。</p>
<h3 id="以破坏为主"><a href="#以破坏为主" class="headerlink" title="以破坏为主"></a>以破坏为主</h3><p>在1979年，测试界的经典之作《软件测试之艺术》（作者C.J.Myers）一书中给出了软件测试的经典定义：测试是为发现错误而执行程序的过程。这个观点较之前证明为主的思路，是一个很大的进步。我们不仅要证明软件做了该做的事情，也要保证它没做不该做的事情，这会使测试更加全面，更容易发现问题。</p>
<p>在书中，Myers还指出两点：好的测试用例是发现迄今为止尚未发现的错误的测试用例；成功的测试执行是发现了至今为止尚未发现的错误的测试执行。相对于“程序测试就是证明程序中不存在错误的过程”而言，Myers的定义是对的，但定义的测试范围过窄。</p>
<h3 id="以评估为主"><a href="#以评估为主" class="headerlink" title="以评估为主"></a>以评估为主</h3><p>在1983年，美国国家标准局提出了测试界很有名的两个名词：验证（Verification）和确认（Validation），也就是我们常说的V&amp;V理论。</p>
<p>人们提出了在软件生命周期中使用分析、评审、测试来评估产品的理论。软件测试工程在这个时期得到了快速的发展：相继出现了测试经理、测试分析师等职称以及发表大量测试刊物，发布相关国际标准。</p>
<p>同时IEEE提出的软件工程标准术语中给软件测试定义是：“使用人工或自动手段来运行或测定某个软件系统的过程，其目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别”。也就是这个时期人们开始关注工具对测试的影响。</p>
<h3 id="以预防为主"><a href="#以预防为主" class="headerlink" title="以预防为主"></a>以预防为主</h3><p>预防为主是当下软件测试的主流思想之一。STEP（产品模型数据交互规范，Systematic Test and Evaluation Process，简称STEP）是最早的一个以预防为主的生命周期模型，STEP认为测试与开发是并行的，整个测试的生命周期也是由计划、分析、设计、开发、执行和维护组成，也就是说，测试不是在编码完成后才开始介入，而是贯穿于整个软件生命周期。</p>
<h2 id="软件测试目的"><a href="#软件测试目的" class="headerlink" title="软件测试目的"></a>软件测试目的</h2><p>从上述测试的发展来看，软件测试的目的也有一个阶段性的变化，我们通过下表来分析一下软件测试目的的演进。</p>
<table>
<thead>
<tr>
<th>20世纪60年代</th>
<th>20世纪70年代中</th>
<th>20世纪90年代</th>
</tr>
</thead>
<tbody><tr>
<td>证明</td>
<td>检测</td>
<td>预防</td>
</tr>
<tr>
<td>表明软件能够工作</td>
<td>发现错误</td>
<td>管理质量</td>
</tr>
</tbody></table>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>保证软件产品是完整的并且可用或可被集成，同时需要尝试在非正常情况下的功能和特性是否可用，评估系统的风险承受能力。</p>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>发现缺陷、错误和系统不足的地方，定义系统的能力和局限性，并提供相关的组件、工作产品和系统质量信息。</p>
<h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>提供预防和减少可能导致错误的信息，在过程中尽早地检测错误，确认问题和风险，并且提前确认解决这些问题和风险的途径。</p>
<p>软件测试目的往往包含如下内容：</p>
<p>1）测试并不仅是为了找出错误，而且要通过分析错误产生的原因和错误的发生趋势，帮助项目管理者发现当前软件开发过程中的缺陷，以便及时改进。</p>
<p>2）需要测试工程师设计出具有针对性的测试方法，以改善测试的有效性。</p>
<p>3）没有发现错误的测试也是有价值的，完整的测试是评估软件质量的一种方法。</p>
<p><strong>综上来看软件测试目的是指尽可能早的发现软件中存在的缺陷并提高软件质量。</strong></p>
<h2 id="软件测试原则"><a href="#软件测试原则" class="headerlink" title="软件测试原则"></a>软件测试原则</h2><p>软件测试理论经过几十年的发展，在测试界提出了很多测试的基本原则，概括出以下8条软件测试基本原则。</p>
<h3 id="1-所有的测试要追溯到用户的需求"><a href="#1-所有的测试要追溯到用户的需求" class="headerlink" title="1.所有的测试要追溯到用户的需求"></a>1.所有的测试要追溯到用户的需求</h3><p>在所有测试活动的过程中，测试人员都应该从客户的需求出发，想用户所想。正如我们所知，软件测试的目标就是验证产品开发的一致性和确认产品是否满足客户的需求，与之对应的任何产品质量特性都应追溯到用户需求。简单说就是一切从用户角度出发。</p>
<h3 id="2．测试应尽早地介入"><a href="#2．测试应尽早地介入" class="headerlink" title="2．测试应尽早地介入"></a>2．测试应尽早地介入</h3><p>根据统计表明，在软件开发生命周期早期引入的错误占软件过程中出现所有错误（包括最终的缺陷）数量的50%～60%。此外，IBM的一份研究结果表明，缺陷存在放大的趋势。所以越是测试后期，为修复缺陷所付出的代价就会越大。因此，软件测试人员要尽早地且不断地进行软件测试，以提高软件质量，降低软件开发成本。</p>
<h3 id="3．测试无法穷举"><a href="#3．测试无法穷举" class="headerlink" title="3．测试无法穷举"></a>3．测试无法穷举</h3><p>在整个测试过程中，测试人员无法考虑到所有可能输入值和它们的组合以及结合所有不同的测试前置条件；所以穷举测试是不可能的，当测试满足一定的出口准则时，测试就应当终止。因此，想要控制测试工作量，在测试成本、收益和风险之间求得平衡；需要通过风险分析、优先级分析以及软件质量模型和不同测试的方法来确定测试关注点，从而代替穷举测试，提高测试覆盖率。</p>
<h3 id="4．避免开发者自测"><a href="#4．避免开发者自测" class="headerlink" title="4．避免开发者自测"></a>4．避免开发者自测</h3><p>测试工作需要严谨的作风、冷静的分析。心理学告诉我们，每个人都具有一种不愿否定自己工作的心理，这种状态导致测试自己程序的障碍。同时，程序员对需求规格说明的错误理解而引入的错误是很难被发现。因此，程序员应避免测试自己的程序，为达到最佳的效果，应由独立的测试小组、第三方来完成测试。</p>
<h3 id="5．群集现象"><a href="#5．群集现象" class="headerlink" title="5．群集现象"></a>5．群集现象</h3><p>Pareto Principle帕累托法则（二八定律）表明：80%的错误集中在20%的程序模块中。也就是说，测试所发现的大部分缺陷和软件运行失效是由少数程序模块引起的。因此，测试过程中要充分注意群集现象，对发现错误较多的程序段或者软件模块，应进行反复的深入的测试。</p>
<h3 id="6．杀虫剂悖论"><a href="#6．杀虫剂悖论" class="headerlink" title="6．杀虫剂悖论"></a>6．杀虫剂悖论</h3><p>杀虫剂用得多了，害虫就有免疫力，杀虫剂就发挥不了效力。同样在测试中，如果测试用例被反复使用时，发现缺陷的能力就会越来越差。为了避免克服这种现象出现，测试用例需要进行定期评审和修改，不断增加新的不同的测试用例来测试软件或系统的不同部分，从而发现更多潜在的缺陷。作为专业的测试人员来说，要具有探索性思维和逆向思维。同理，测试方法也需要不断地变化。</p>
<h3 id="7．不存在缺陷的谬论"><a href="#7．不存在缺陷的谬论" class="headerlink" title="7．不存在缺陷的谬论"></a>7．不存在缺陷的谬论</h3><p>通过测试可以减少软件中存在未被发现缺陷的可能性，但即使测试没有发现任何缺陷，也不能证明软件或系统是完全正确的。也就是说，测试只能证明软件存在缺陷，不能证明软件不存在缺陷。比如，不能满足用户期望的或用户不满意，也是一种缺陷。</p>
<h3 id="8．测试活动依赖于测试背景"><a href="#8．测试活动依赖于测试背景" class="headerlink" title="8．测试活动依赖于测试背景"></a>8．测试活动依赖于测试背景</h3><p>针对不同的测试背景，进行的测试活动也不同，测试策略和测试方法在选取上也有所不同。比如，银行产品和电商平台。在银行产品中要将安全放到首位；在电商平台中要把兼容性、性能放到首位。在实际测试过程中，测试人员应该在测试原则指导下进行测试活动。</p>
<p>软件测试原则有助于测试人员进行高质量的测试，尽早尽可能多的发现缺陷，并负责跟踪和分析软件中的问题，对存在的问题和不足提出质疑和改进，从而持续改进测试过程。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-10</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-10/</url>
    <content><![CDATA[<h1 id="如何记录一个Bug"><a href="#如何记录一个Bug" class="headerlink" title="如何记录一个Bug"></a>如何记录一个Bug</h1><p>当测试人员在执行测试用例的过程中发现Bug时，测试人员应该如何记录这个Bug？如何确保开发人员能理解自己所提交的Bug？本节将详细解答这些问题。</p>
<span id="more"></span>

<h1 id="一个Bug所包括的内容"><a href="#一个Bug所包括的内容" class="headerlink" title="一个Bug所包括的内容"></a>一个Bug所包括的内容</h1><p>通常情况下，一个Bug应包括以下信息点</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/87080/1611067675140-af0bbec5-46a1-4984-b626-84fe2df07a44.png" alt="img"></p>
<p>每个公司的不同项目对Bug应包括的信息点可能存在一些细小的差异，但大体思想是一致的，进入公司后按照公司的要求和模板书写便可。</p>
<h1 id="Bug记录的正确范例"><a href="#Bug记录的正确范例" class="headerlink" title="Bug记录的正确范例"></a>Bug记录的正确范例</h1><p>例1：某测试人员打开XYC邮箱的登录首页，输入正确的用户名和密码后成功登录到XYC邮箱内页，然后单击“写信”按钮进入写信页面，随后输入正确的邮件地址、正确的主题、正确的正文，然后单击“发送邮件”按钮，但之后页面没有任何反应，无法发送邮件。很明显，这就是一个Bug，那测试人员应如何记录这个Bug呢？</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/87080/1611067746540-7d3d9304-6713-4c86-ad68-c0f3f2fe4f6c.png" alt="img"></p>
<p>对于Bug的记录，需要注意以下3点。</p>
<p>（1）Bug的概要一定要清晰简洁。</p>
<p>（2）在Bug的具体描述中，测试的步骤和使用到的具体数据都要清楚地写出来；在Bug的具体描述中尽可能多地提供一些必要信息，如本例具体描述中的第6步。</p>
<p>（3）如果可以截图，一定要截图，因为这是最直接的证据，一般的操作系统都有截图软件。以上3点都是要提交给开发人员的关键信息，开发人员需要依据这些关键信息去定位Bug的原因。</p>
<p>例2：某测试人员打开XYC邮箱的登录页面，输入错误的用户名和密码，随后单击“登录”按钮，此时系统无法登录，但系统也没有给出任何提示。很明显，这也是一个Bug。那测试人员应如何记录这个Bug呢？</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/87080/1611067852946-003642dd-acef-4838-b32d-5d3a0189c479.png" alt="img"></p>
<p>其中对于Bug的优先级，相信初级软件测试人员都可以正确判断，提醒大家一点：设置处理Bug的优先级的目的是告诉开发人员处理此Bug的优先级别，以便开发人员合理地安排Bug修复工作。</p>
<p>例3：某测试人员打开XYC邮箱的登录页面，输入正确的用户名和密码后成功登录邮箱，然后单击“写信”按钮进入写信页面，测试人员准备在收件人地址栏中输入一个邮箱通讯录中已存在的邮件地址，但当测试人员输入该邮件地址的第一个字符时，发现系统并没有自动联想出以该字符开头的所有邮件地址。</p>
<p>分析：如果该需求文档并没有要求收件人地址栏要具备自动联想功能，那么此问题，测试人员就可以当作建议性问题提出来。测试人员应该如何记录这个建议性的Bug呢？</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/87080/1611067923360-85b02310-faa2-494b-b737-7ff04c59ba8e.png" alt="img"></p>
<p>描述Bug的发生过程并记录相关数据，这对一名初级测试人而言并不是一件很困难的事情。初级软件测试人员在记录一个Bug时，应尽可能多地提供一些详细的信息和截图。本书所列的Bug示例也许并不是最好的，初级软件测试人员入职后应多参考其他同事曾提交过的Bug示例单，并学习其中的优点。</p>
<p>总之，提交清晰的Bug示例单是初级软件测试人员十分重要的一项工作，如果Bug示例单中的内容缺少关键步骤和具体数据等重要信息，这不仅给开发人员修复Bug带来难度，还有可能会被直接退回给测试人员并要求重新书写Bug示例单。</p>
<h1 id="求职问题"><a href="#求职问题" class="headerlink" title="求职问题"></a>求职问题</h1><p>如何提交高质量的缺陷？</p>
<p>参考答案：</p>
<ol>
<li><p>bug概要 简洁，清晰，描述缺陷的要点，能够描述清除是什么问题。</p>
</li>
<li><p>bug的具体描述，细节越详细越好，以及出错数据描述清楚。</p>
</li>
<li><p>可以加上对应的截图和日志。</p>
</li>
<li><p>所测试软件版本号以及测试环境，不同版本，不同环境可能会造成不同测试结果。</p>
</li>
</ol>
<p>如果你发现了一个bug，但是这个bug之后再也无法重现，你会怎么办？</p>
<p>参考答案：</p>
<ol>
<li><p>尽可能的保留截图，以及对应的日志，保留好测试现场。没有重现问题可能是没有触发引起此bug的某个点，所以作为测试人员我会想尽一切办法让这个bug重现。</p>
</li>
<li><p>如果实在无法重现，还是会提交bug给开发人员。如果有截图和日志，会一并提交。</p>
</li>
<li><p>如果开发人员要求重现，那么测试人员就需要后期继续观察，如果最终还是无法重现，会将此问题提交给测试经理。由测试经理和开发人员商定解决办法。虽然现在不能重现，但是不代表不会在用户哪里重现。</p>
</li>
</ol>
<p>如果开发人员不修改你发现的bug，原因是因为修改的成本比较高，这个bug只是影响用户体验而已，你会怎么办？</p>
<p>参考答案：</p>
<p>我觉得影响用户得设计不是好的设计，任何影响用户体验的问题都是大问题，这个产品就不是一款好产品。</p>
<p>如果每个问题都因为成本高就不去修改的话，是无法持续提升产品的质量。</p>
<p>我觉得只要是问题，无论大小，测试人员都应该要求开发人员去修改，这是对产品负责，也是对用户负责。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-11</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-11/</url>
    <content><![CDATA[<h1 id="对Bug起争议时的处理"><a href="#对Bug起争议时的处理" class="headerlink" title="对Bug起争议时的处理"></a>对Bug起争议时的处理</h1><p>测试人员和开发人员因Bug起争议的事情常有发生，例如开发人员认为这不算是一个Bug，或认为这个Bug不重要，不需要修改，而测试人员认为这是一个很严重的Bug，需要开发人员修改，或因其他原因起了争议等。如果出现了这些情况，测试人员应如何处理呢？</p>
<p>(1）任何争议都需要“对事不对人”，不能因为Bug而激化了双方的矛盾。</p>
<p>（2）有很多初级软件测试人员提交的Bug单流转到开发人员那里后，开发人员看不懂。原因在于测试人员提交的Bug单没有描述清楚，这是一个非常常见的现象。测试人员提交的Bug单一定要描述清楚，并需要有充足的依据和理由。</p>
<p>（3）如果Bug单写清楚了，但开发人员还是不愿意修改的话，可以找一个合适的时间，心平气和地与开发人员沟通，说明此Bug对产品质量可能产生的不良影响，测试人员在沟通过程中不能意气用事。</p>
<p>（4）经沟通后，如果开发人员还是不愿意修改的话（当然开发人员不修改也有他们的原因），那么此时可以向测试经理汇报这一情况，由测试经理出面解决，或是由测试经理召开Bug评审大会（开发人员、测试人员、产品经理三方人员参与，有时也包括项目经理），共同定夺。</p>
<p>（5）有些初级软件测试人员把Bug提交到开发人员那后，经过开发人员的各种解释，就会同意开发人员的意见，也认为这确实不是一个Bug，从而忽略这个问题，这也是经常发生在初级软件测试人员身上的事情。这就要求测试人员提交Bug的过程要有原则性，这也是作为一名合格的测试人员最重要的特征之一，对待问题需要坚持原则。</p>
<p>（6）测试人员应和开发人员面对面或通过电子邮件、电话等方式保持密切沟通，共同协商和处理Bug，以减少两者间的隔膜，增加测试人员与开发人员之间的信任和了解。直接沟通也应贯穿到产品开发、测试的每个环节当中。</p>
<span id="more"></span>

<h1 id="回归测试的策略"><a href="#回归测试的策略" class="headerlink" title="回归测试的策略"></a>回归测试的策略</h1><p>假如XYC邮箱的测试工作已完成，Bug已全部修复，并已达到上线标准。接下来就以XYC邮箱为例来回顾一下XYC邮箱回归测试的基本流程</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/87080/1611068189193-645fccd3-269e-4d65-ae65-42e44de27439.png" alt="img"></p>
<p>下面对以上流程图进行一个简要说明。</p>
<p>（1）开发人员把最初开发出来的XYC邮箱命名为XYC邮箱V1.0版本。测试人员就会针对XYC邮箱V1.0版本进行第一轮测试。第一轮测试执行完成后，测试人员一共发现了100个Bug，其中存在多个严重问题，XYC邮箱无法达到上线标准。</p>
<p>（2）开发人员随后对XYC邮箱V1.0版本的这100个Bug进行修复。Bug修复完成后，就把修复后的软件命名为XYC邮箱V1.1版本，以区别V1.0版本。接着测试人员就会在V1.1版本上进行第二轮的回归测试以验证开发人员是否修复了这100个Bug，结果发现100个Bug中有15个Bug并没有修复好，另外还新引入了25个Bug，相当于XYC邮箱V1.1版本还存在40个Bug，且存在多个严重问题，故达不到上线标准。</p>
<p>（3）开发人员随后对XYC邮箱V1.1版本上的这40个Bug进行修复，Bug修复完成后，就把修复后的软件命名为XYC邮箱V1.2版本，以区别V1.1版本。接着测试人员就会在V1.2的版本上进行第三轮的回归测试以验证开发人员是否修复了这40个Bug，结果发现40个Bug中有2个Bug并没有修复好，另外还新引入了10个Bug，相当于XYC邮箱V1.2版本存在12个Bug，且存在1个严重问题，故达不到上线标准。</p>
<p>（4）开发人员随后对XYC邮箱V1.2版本的这12个Bug进行修复，Bug修复完成后，就把修复后的软件重新命名为XYC邮箱V1.3版本，以区别V1.2版本。接着测试人员就会在V1.3的版本上进行第四轮的回归测试以验证开发人员是否修复了这12个Bug，结果发现仅有2个Bug存在，且这2个Bug都是建议性的问题，并不影响用户对功能的使用和体验，达到上线标准，此时XYC邮箱V1.3版本就可以上线让用户使用了。</p>
<p>以上展示的就是一个回归测试的基本流程，从中可以看到：</p>
<p>（1）即使上一轮的Bug被修复了，在下一轮的测试中还可能发现新的Bug，并不是说上一轮的Bug修复好了就不会再出现其他问题了；</p>
<p>（2）软件测试并不是测试一轮就完成了，一般情况下，一个软件产品可能需要经过多轮反复测试和验证才能达到上线标准。</p>
<h1 id="回归测试的基本策略"><a href="#回归测试的基本策略" class="headerlink" title="回归测试的基本策略"></a>回归测试的基本策略</h1><p>回归测试的策略一般由测试经理或测试组长制定，初级软件测试人员只要按相应的策略执行测试即可。现以XYC邮箱的测试为例，简要介绍一下回归测试的基本策略。</p>
<p>（1）回归测试时执行全部的测试用例。</p>
<p>XYC邮箱V1.0版本的第一轮测试中发现100个Bug，那么在第二轮的回归测试中，除了测试这100个Bug之外，其他所有功能点的测试用例需要重新再执行一遍，这样做的原因在于，回归测试的V1.1版本是在修改了V1.0版本存在的100个Bug的基础上建立起来的。由于修复了大量的Bug，这就意味着要改动大量的代码，当多处代码被改动后谁也不能保证其他功能点不受影响，所以对所有的功能点进行测试是比较保险的，也是比较周密的，不会遗漏任何的测试点。使用此策略的时间周期和人力成本也是比较高的，一般情况下，当第一轮测试发现的Bug数量过多的情况下，第二轮回归测试应该执行全部的测试用例。</p>
<p>（2）选择重要的功能点、常用的功能点、与Bug相关联的功能点进行回归测试。</p>
<p>XYC邮箱的第二轮回归测试中又发现了40个Bug，那么在第三轮的回归测试过程中，除了要测试这40个Bug之外，还应当把重要的功能点、常用的功能点、与Bug相关联的功能点的测试用例再执行一遍，其他次要的测试用例可在时间充足的情况下选择性执行。</p>
<p>（3）选择性执行关键功能点的测试用例。</p>
<p>XYC邮箱的第三轮回归测试中又发现了12个Bug，那么在第四轮的回归测试过程中，除了测试这12个Bug之外，还可以选择性地执行一些关键功能点的测试用例，其他测试用例可在时间充足的情况下选择性执行。</p>
<p>（4）仅测试出现Bug的功能点。</p>
<p>如果测试组认为软件的功能点已经十分稳定了，回归测试的时候可选择仅测试出现Bug的功能点。每个策略都有其适应的场景，不能一概而论，应当以Bug的数量和严重程度为导向，深入分析，然后得出适合本项目的回归测试策略。</p>
<p>回归测试是在系统测试人员完成了需求评审、测试计划、用例设计、环境搭建、Bug提交等关键性的测试工作之后所要开展的工作，可以说此时的测试人员已经完全融入测试体系当中，也完全可以胜任相应的测试工作了。至于回归测试的策略，初级软件测试人员可通过先学习测试经理制定的策略，再从执行回归测试策略过程中进一步提升自己的测试经验。</p>
<h1 id="测试如何应对新的开发模式？"><a href="#测试如何应对新的开发模式？" class="headerlink" title="测试如何应对新的开发模式？"></a>测试如何应对新的开发模式？</h1><h1 id="为什么需要测试左移，测试右移？"><a href="#为什么需要测试左移，测试右移？" class="headerlink" title="为什么需要测试左移，测试右移？"></a>为什么需要测试左移，测试右移？</h1><p>测试可以保证产品质量，重要性不言而喻。但，要做好测试也比较困难，需要克服很多挑战。尤其是，持续交付、敏捷开发等开发模式为传统     软件测试方式带来了更大的时间压力。</p>
<p>我们先来看看下面这种熟悉的测试方式都有什么问题：测试人员接到项目后参与需求评审，然后根据需求文档写用例、准备脚本，等开发提测之后正式开始测试、提 Bug、回归，测试通过后就结束了，项目交给运维上线，之后投入下一个项目继续重复这样的流程。</p>
<p>这样的流程看似没什么错，但有两大问题：</p>
<ul>
<li>测试人员非常被动。当需求质量、开发质量较差的时候，测试人员只能被动接受。</li>
<li>但同时，测试又被认为是质量的责任人。如果因为需求质量、开发提测质量差而导致上线延期，大家通常会首先怪罪测试团队。</li>
</ul>
<p>这些问题，在新的开发模式下愈发严重。因为这些新的开发模式有一个共同点，就是要缩短产品的交付周期，对自动化的要求越来越高，能够专门留给传统竖井流程中测试环节的时间越来越短，自然更难保证质量。在极端的情况下，比如在持续部署的模式下，所有测试都是自动化的，已经完全没有留给测试人员专门进行手工测试的时间了。与此同时，测试的能力和质量又是这些开发模式成功的关键。否则，即使可以频繁地构建产品，质量不过关价值也为零。所以，在快速开发模式的挑战下，测试左移、测试右移就应运而生了。这些测试模式，能让测试人员拥有更多主动权，以及更多的时间进行测试。</p>
<p>那，到底什么是测试左移和测试右移呢？</p>
<h1 id="什么是测试左移和测试右移？"><a href="#什么是测试左移和测试右移？" class="headerlink" title="什么是测试左移和测试右移？"></a>什么是测试左移和测试右移？</h1><p>测试左移和右移，就是把测试的范围从传统测试的节点中释放出来，向左和右扩展。</p>
<p>向左扩展，就是让测试介入代码提测之前的部分。比如，扩展到开发阶段，在架构设计时就考虑产品的可测试性，并尽量进行开发自测等。另外，测试可以更进一步扩展到需求评审阶段，让测试人员不只是了解需求，更要评估需求的质量，比如分析需求的合理性以及完整性等。</p>
<p>类似的，测试右移，是让测试介入代码提测之后的部分。比如，测试人员在产品上线过程中，利用线上的真实环境测试。另外产品上线之后，测试人员仍然介入，通过线上监控和预警，及时发现问题并跟进解决，将影响范围降到最低。这样一来，测试人员不但有更多的时间进行测试，还能发现在非生产环境中难以发现的问题。</p>
<h1 id="测试左移的原则和实践"><a href="#测试左移的原则和实践" class="headerlink" title="测试左移的原则和实践"></a>测试左移的原则和实践</h1><ul>
<li><p>调整团队对测试的态度；</p>
</li>
<li><p>把测试添加到开发和产品需求步骤中；</p>
</li>
<li><p>频繁测试，快速测试。</p>
</li>
</ul>
<h2 id="测试左移原则一：调整团队对测试的态度"><a href="#测试左移原则一：调整团队对测试的态度" class="headerlink" title="测试左移原则一：调整团队对测试的态度"></a>测试左移原则一：调整团队对测试的态度</h2><p>调整团队对测试的态度，打破竖井的工作方式，是测试左移的前提。一个有效的办法是，按照功能的维度管理团队，让整个功能团队对产品负责。也就是说，如果产品质量出现问题，不只是测试团队“背锅”，而是会影响整个功能团队的绩效。同时，让质量问题的直接责任人承担更多的责任，来进一步增强团队成员的责任心。这种利益绑定的办法，虽然简单但非常有效，只不过出现质量问题时要记得进行根因分析，以避免再次出现类似问题。</p>
<p>另外，还要改变团队成员对测试工作的认知。传统的工作方式中，我们通常认为发现 Bug 最重要，但其实为了提高产品质量，更重要的是预防 Bug。所以说，在测试左移的过程中，我们应该更聚焦在预防 Bug 上。</p>
<h2 id="测试左移原则二：把测试添加到开发和产品需求步骤中"><a href="#测试左移原则二：把测试添加到开发和产品需求步骤中" class="headerlink" title="测试左移原则二：把测试添加到开发和产品需求步骤中"></a>测试左移原则二：把测试添加到开发和产品需求步骤中</h2><p>测试左移的第一步，是把测试工作融入到开发步骤中。常用的办法是，让测试人员参与到开发阶段的方案设计中，了解开发的实现方式。因为很多开发人员可能只熟悉他负责的那一部分，而测试人员往往对全局更加了解，所以测试人员要评估改动范围以及是否有遗漏的模块和系统。</p>
<p>另外一个比较彻底，也很有效的方法是全栈开发，通过运维团队提供工具和支持，让开发人员尽量参与到运维工作中去。对于测试来说，也是同样的道理。我们可以让测试团队转型，进行工具开发，并更多地去支持专项测试，比如性能测试、安全测试等，通过“使能”的办法，让开发人员完成功能测试，包括单元测试、集成测试等。</p>
<p>说到让开发人员完成部分测试工作，常常会听到很多质疑声。反对者认为，测试人员的心理模型跟开发人员不一样，他们更倾向于去找问题。而开发人员面对自己开发的产品，潜意识里就不愿意去找问题，比如，他们不愿意专门尝试各种边界输入进行测试，而把自己开发的功能搞崩溃。所以，开发人员和测试人员更适合分开。</p>
<p>这种观念，在 10 年前瀑布开发模式盛行时就深入人心。我曾经也非常认同，但在 Facebook 工作了 5 年后改变了看法。如果你能够把开发人员的责任界定得很清楚，谁开发的产品谁要保证质量，那么开发人员自然而然地就会去尝试做好测试，比如进行边界测试。而且，开发人员最了解自己写的代码，所以他能够最高效地对自己的代码进行测试。</p>
<p>当然，做全栈开发的同时我们仍会保留一部分功能测试人员，毕竟从竖井模式转变到全栈模式是一个循序渐进的长期过程。不过 Facebook 做到了极致，完全没有了功能测试人员，也就是我们所说的“去 QA”。</p>
<p>测试左移到了开发阶段之后，再往左移一步就到了产品设计阶段，在这里，测试人员除了解需求外，更重要的是评估需求的质量。</p>
<p>我推荐使用 BDD（Behavior Driven Development，行为驱动开发）的方法进行开发，促进团队在需求评审时更多地考虑测试。BDD 是通过特定的框架，用自然语言或类自然语言，按照编写用户故事或者用例的方式，从功能使用者的视角描述并编写测试用例，从而让业务人员、开发人员和测试人员着眼于代码要实现的业务行为，并以此为依据通过测试用例进行验证。</p>
<h2 id="测试左移原则三：频繁测试，快速测试"><a href="#测试左移原则三：频繁测试，快速测试" class="headerlink" title="测试左移原则三：频繁测试，快速测试"></a>测试左移原则三：频繁测试，快速测试</h2><p>测试左移的第三个重要原则是，频繁测试、快速测试。在测试左移之前，我们需要等待提测，比较被动，不能频繁测试。但测试左移到开发阶段之后，我们就有了很大的自由度去频繁运行测试，从而更好地发挥测试的作用，尽早发现更多的问题。</p>
<p>这里最重要的方法就是，我在讲持续开发时提到的几个关于验证的操作，具体包括：</p>
<ul>
<li><p>规范化、自动化化本地检查；</p>
</li>
<li><p>建设并自动化代码入库前的检查流程；</p>
</li>
<li><p>提供快速反馈，促进增量开发。</p>
</li>
</ul>
<p>另外，为了能够顺利、频繁地运行测试，我们还要提升测试运行的速度。给测试提速的常见办法包括：</p>
<ul>
<li><p>并行运行。比如把测试用例放到多台机器上运行，用资源换时间。</p>
</li>
<li><p>提高构建速度。比如使用精准构建，因为通常构建之后才能运行测试。</p>
</li>
<li><p>精准测试，也就是只运行跟改动最相关的测试。可以建立需求与代码的关系，以及需求与测试用例的关系，从而在代码改动时重点关注与之最相关的测试用例。</p>
</li>
<li><p>分层测试，即不同情况运行不同测试用例集合。</p>
</li>
<li><p>减少不必要的用例。比如，识别不稳定的用例，对其删除或者优化。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-2</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-2/</url>
    <content><![CDATA[<h1 id="软件测试阶段划分"><a href="#软件测试阶段划分" class="headerlink" title="软件测试阶段划分"></a>软件测试阶段划分</h1><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试（Unit Testing，简称UT）是对软件基本组成单元（函数或类）进行检测的测试工作。其目的是检测与详细设计说明书（Low Level Design，简称LLD）的符合程度。</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试（Integration Testing，简称IT）是在单元测试的基础上，将所有的模块按照设计的要求进行集成，主要验证组装后的功能以及模块之间的接口是否正确安装的测试工作。主要目的是检测软件与概要设计说明书（High Level Design，简称HLD）的符合程度。集成测试的主要工作是测试模块之间的接口，但是接口测试不等于集成测试，这是个以面盖点的问题。比如，可以说北京是中国的城市，但不能说中国的城市就是北京。</p>
<h2 id="集成测试工具"><a href="#集成测试工具" class="headerlink" title="集成测试工具"></a>集成测试工具</h2><p>能够直接用于集成测试的测试工具不是很多，一般来说，一些通用的商用测试工具由于需要满足一定的通用性，因此在实际使用的时候功能是有限的，大部分工具需要进行二次开发。集成测试主要关注接口的测试，常用的接口测试工具：POSTMan、HTTPRequest、jmeter等。</p>
<h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>系统测试（System Testing，简称ST）是将已经通过集成测试的软件系统，与计算机硬件、外设、数据库、网络等其他元素结合在一起，在实际运行环境下，进行的一系列的测试工作。</p>
<p>系统测试通常是由独立的测试团队来完成，其测试的主要依据是需求规格说明书。</p>
<p>系统测试的类型主要有：</p>
<span id="more"></span>

<h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>功能测试是系统测试中最基本的测试，它不管软件内部的实现逻辑，主要根据产品的需求规格说明书和测试需求的列表，来验证产品的功能实现是否符合产品的需求规格。特别要注意的是一些隐含功能的需求。功能测试主要检查被测试对象是否存在以下几种错误：</p>
<ul>
<li><p>是否有不正确、遗漏的或多余的功能。</p>
</li>
<li><p>功能实现是否满足用户的需求和系统设计的隐藏需求。</p>
</li>
<li><p>对输入是否做了正确的响应，对输出结果是否做了正确的显示。</p>
</li>
<li><p>对系统的流程设计是否正确、合理。</p>
</li>
<li><p>所有的功能是否达到全覆盖。</p>
</li>
</ul>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>性能测试是指在一定软件、硬件及网络环境下，对系统的各项性能指标来进行测试，主要检测其性能特性否满足特定的性能需求。常用的性能指标包括并发数、响应时间、每秒处理的事务数、吞吐量、点击率、访问量以及硬件资源等。</p>
<p>性能测试需要从以下两个方面考虑：</p>
<ul>
<li>验证系统实现的性能是否与性能需求完全一致。</li>
<li>检测系统实现的具体性能到底怎么样。</li>
</ul>
<h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><p>压力测试也称强度测试，也是性能测试的一种，是指在极限状态下，长时间或超大负荷地连续运行的测试，主要检测被测系统的性能、可靠性、稳定性等。</p>
<p>压力测试检的目的是检查系统在资源超负荷的情况下的抗压能力。</p>
<p>压力测试的基本步骤如下：</p>
<ul>
<li>进行简单的多任务测试。</li>
<li>在简单压力缺陷被修正后，增加系统的压力直到系统中断。</li>
</ul>
<h3 id="容量测试"><a href="#容量测试" class="headerlink" title="容量测试"></a>容量测试</h3><p>容量测试是指检查当系统运行在大量数据，甚至最大或更多的数据测试环境下，系统是否会出问题。还可以看作系统性能指标中一个特定环境下的一个特定性能指标，即设定的界限或极限值。容量测试是面向数据的，并且它的目的是显示系统可以处理目标内确定的数据容量。</p>
<p>进行容量测试一般可以通过以下几个步骤来完成：</p>
<ul>
<li><p>首先分析系统的外部数据源，并对数据进行分类；</p>
</li>
<li><p>对每类数据源分析可能的容量限制，对数据类型分析记录的长度和数量限制；</p>
</li>
<li><p>对每类数据源，构造大容量数据对系统进行测试；</p>
</li>
<li><p>分析测试结果，与期望值进行比较，最后确定系统的容量瓶颈；</p>
</li>
<li><p>对系统进行优化并重复上面的步骤，直到系统达到期望的容量处理能力。</p>
</li>
</ul>
<h3 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h3><p>安全试是用来验证系统内的保护机制是否能够在实际应用中保护系统不受到非法的侵入。该测试用来保护系统本身数据的完整性和保密性。随着互联网的发展，安全测试尤为重要，特别是一些金融类的产品，往往都把安全放到首位。</p>
<h3 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h3><p>兼容性测试是指检查软件在一定的软硬件、数据库、网络、操作系统环境下是否可以正确地进行交互和共享信息。兼容性测试的策略有向下兼容、向上兼容、交叉兼容。</p>
<p>兼容性测试一般考虑以下几点：</p>
<ul>
<li><p>软件本身能否向前或向后兼容，即不同版本之间的兼容。</p>
</li>
<li><p>软件能否与其他相关软件的兼容。</p>
</li>
<li><p>软件在不同的操作系统上兼容。</p>
</li>
<li><p>数据的兼容性，主要是指数据能否共享等。</p>
</li>
<li><p>硬件上的兼容性，如手机APP软件需要考虑不同品牌的手机。</p>
</li>
</ul>
<h3 id="配置测试"><a href="#配置测试" class="headerlink" title="配置测试"></a>配置测试</h3><p>配置测试主要是指测试系统在各种软硬件配置、不同的参数配置下系统具有的功能和性能。配置测试并不是一个完全独立的测试类型，需要和其他测试类型相结合，如功能测试、性能测试、兼容性测试等。</p>
<p>通常配置测试的可以分为服务器端和客户端的配置测试。</p>
<ul>
<li>服务器端的配置需要考虑服务器的硬件、Web服务器、数据库服务器等。</li>
<li>客户端的配置需要考虑操作系统、浏览器、分辨率、颜色质量等。</li>
</ul>
<h3 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h3><p>异常测试是指通过人工干预手段使系统产生软、硬件异常，通过验证系统异常前后的功能和运行状态，达到检测系统的容错、排错和恢复的能力。它是系统可靠性评价的重要手段。</p>
<p>通常异常测试关注的要点如下:</p>
<ul>
<li><p>强行关闭软件的数据库服务器或者用其他方式导致数据库死机。</p>
</li>
<li><p>非法删除或修改数据库中的表数据或者表。</p>
</li>
<li><p>断开网络或者人为增加网络流量。</p>
</li>
<li><p>强行重启软件的web服务器或者中间件服务器，测试系统的恢复能力。</p>
</li>
<li><p>通过人为手段，增加cpu、内存、硬盘等负载进行测试。</p>
</li>
<li><p>对部分相关软件测试机器进行断电测试。</p>
</li>
</ul>
<h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>安装测试就是确保该软件在正常情况和异常情况的不同条件下，都能进行安装。安装系统是开发人员的最后一个活动，通常在开发期间不太受关注。</p>
<p>在进行安装测试时需要关注以下3点：</p>
<ul>
<li><p>安装前测试：首先要检查安装包文件以及安装手册是否齐全，其次关注是否有权限以及空间进行安装，还需要考虑杀毒软件和防火墙的影响。</p>
</li>
<li><p>安装中测试：主要是安装流程的测试以及检查安装时文件、注册表、数据库的变动。</p>
</li>
<li><p>安装后测试：主要检查安装好的软件是否能正常运行，基本功能是否可以使用。</p>
</li>
</ul>
<h3 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h3><p>网络测试是在网络环境下和其他设备对接，进行系统功能、性能与指标方面的测试，保证设备对接正常。网络测试考察系统的处理能力、兼容性、稳定性、可靠性以及用户使用等方面。网络测试的关注点如下：</p>
<ul>
<li><p>功能方面需要考虑的是协议测试和软件内的网络传输与架构。</p>
</li>
<li><p>性能方面需要考虑网络吞吐率和网络I/O占有率等。</p>
</li>
<li><p>安全性则考虑网络传输加密，常用的加密方式有MD5和RSA加密。</p>
</li>
<li><p>网络技术上对网络数据收集、分析，常用网络监控工具有Wireshark，Fiddler，Charles等。</p>
</li>
</ul>
<h3 id="可用性测试"><a href="#可用性测试" class="headerlink" title="可用性测试"></a>可用性测试</h3><p>可用性测试和可操作性测试有很大的相似性，它们都是为了检测用户在理解和使用系统方面是否满意。这包括系统功能、系统发布、帮助文档和过程，以保证用户舒适的和系统交互。在实际测试的时候，通过观察有代表性的用户，完成产品的典型任务，而界定出可用性问题并解决这些问题。它的目的就是让产品用起来更容易。</p>
<p>可用性测试的难点在于可用性有时候比较难以量化，因此可用性测试通常而言由行业专家或用户来进行。行业专家结合自己对行业和用户的了解来进行测试。在系统测试中，需要结合一些经验进行分析，要针对一些容易量化的特性进行检查，如：菜单级数、快捷键的使用和网站导航等。</p>
<h3 id="健壮性测试"><a href="#健壮性测试" class="headerlink" title="健壮性测试"></a>健壮性测试</h3><p>健壮性测试有时也叫容错性测试（Fault ToleranceTesting），主要用于测试系统在出现故障时，是否能够自动恢复或者忽略故障继续运行。为了使系统具有良好的健壮性，要求设计人员在做系统设计时必须周密细致，尤其是在系统的异常处理方面。即一个健壮的系统是设计出来的而不是测试出来的。</p>
<p>健壮性有两层含义：一是容错能力，二是恢复能力。</p>
<ul>
<li>容错性测试：通过构造不合理的输入来引诱软件出错，如输入错误的数据类型、输入定义域之外的数值等。</li>
<li>恢复性测试：重点考察系统能否重新运行、有无重要的数据丢失、是否毁坏了其他相关的软、硬件。</li>
</ul>
<h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><p>文档测试的目标是验证用户文档是否正确的并且保证操作手册的过程能够正确工作。主要针对系统提交给用户的文档的验证。文档测试有助于发现系统中的不足并且使得系统更可用。因此文档的编制必须保证一定的质量，通常考虑有以下几点：</p>
<ul>
<li><p>针对性：分清读者对象，按不同类型、层次的读者，决定怎样适应他们的需要。</p>
</li>
<li><p>精确性：文档的行文应当十分确切，不能出现多义性的描述。</p>
</li>
<li><p>清晰性：文档编写应力求简明，适当可以配图表以增强其清晰性。</p>
</li>
<li><p>完整性：任何一个文档都应当是完整的、独立的、自成体系的。</p>
</li>
<li><p>灵活性：各个不同软件项目，其规模和复杂程度有着许多实际差别，文档测试应灵活应对。</p>
</li>
</ul>
<h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><p>验收测试是部署软件应用之前的最后一个测试操作。是以用户为主的测试，软件开发人员和软件质量保证人员也应参加。由用户参与测试用例的设计，通过用户界面输入测试数据，并分析测试的输出结果，一般使用生产实践中的实际数据进行测试。在测试过程中除了考虑功能和性能外，还应对软件的兼容性、可移植性、可维护性、可恢复性以及法律法规、行业标准进行测试。</p>
<p>验收测试可分为正式验收和非正式验收2种。</p>
<ul>
<li>正式验收就是用户验收测试（UAT）</li>
<li>非正式验收包括α测试和β测试</li>
</ul>
<h3 id="UAT测试"><a href="#UAT测试" class="headerlink" title="UAT测试"></a>UAT测试</h3><p>UAT（User Acceptance Test），也就是用户验收测试或用户可接受测试。它是系统开发生命周期方法论的一个阶段，这时相关的用户或独立测试人员根据测试计划和结果对系统进行测试和接收。它让系统用户决定是否接收系统。它是一项确定产品是否能够满足合同或用户所规定需求的测试，由系统管理性和防御性控制。</p>
<p>因为测试人员并不了解用户用什么样的手段和思维模式进行测试。所以UAT主要是要求用户参与测试流程，并得到用户对软件的认可，鼓励用户自己进行测试设计和进行破坏性测试，充分暴露系统的设计和功能问题，显然，用户的认可和破坏性测试是难点。</p>
<h3 id="α测试"><a href="#α测试" class="headerlink" title="α测试"></a>α测试</h3><p>α（Alpha）测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试。α测试是在受控制的环境下进行的测试，即软件在一个自然设置状态下使用，开发者坐在用户旁边，随时记下错误情况和使用中的问题，主要目的是评价软件产品的FLURPS（即功能、局域化、可用性、可靠性、性能等），尤其注重产品的界面和特色。α测试人员是除产品研发人员之外最早见到产品的人，他们提出的功能和修改建议是很有价值的。</p>
<h3 id="β测试"><a href="#β测试" class="headerlink" title="β测试"></a>β测试</h3><p>β（Bate）测试是由软件的多个用户在一个或多个用户的实际使用环境下进行的测试。与α测试不同的是，β测试时开发者通常不在测试现场。因而，β测试是在开发者无法控制的环境下进行的软件现场应用。在β测试过程中，由用户记录下遇到的所有问题，包括客观的和主观认定的，定期向开发者报告，开发者在综合用户的报告后做出修改，再将软件产品交付给全体用户使用。</p>
<h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p>回归测试主要指软件在测试或其他活动中发现的缺陷经过修改后，重新进行测试，目的是验证修改后缺陷是否得到了正确的修复，同时还要关注有没有引入新的缺陷或导致其他代码产生缺陷或错误。</p>
<h3 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h3><p>在大部分软件测试工作中，单元测试与集成测试是由开发工程师完成的，而系统测试是由软件测试工程师完成的。为了提高软件测试工程师测试的有效性，当软件测试工程师拿到开发工程师提交的版本后，就需要进行一次冒烟测试。冒烟测试主要指测试软件版本中的主要功能是否实现，速度很快，一般一到两个小时即可完成。夸张地说，抽一根香烟的时间就可以完成测试。还有一个说法来源于硬件测试，一般硬件组装完毕，上电后，如果电路出现冒烟故障，则不必进行更深入的测试。在软件测试中，如果冒烟测试没有通过，就需要返回给开发工程师重新修改后再测试。</p>
<h3 id="A-B测试"><a href="#A-B测试" class="headerlink" title="A/B测试"></a>A/B测试</h3><p>A/B测试本质上是使用数据来驱动决策。关于一个决策（例如，登录页面的设计，注册引导方式或者后端算法服务），传统方式更倾向于根据主观经验进行决策，但是经验并不一定是完全正确的，且一旦决策失误会影响到用户体验，导致损失大量用户。而A/B测试就是用于辅助决策的，我们通过分析A/B测试的结果，设计处两个甚至多个版本，按照线上或者其它方式对多个版本进行划分，最终通过客户反馈效果或者收益大小来决定使用哪个版本。</p>
<p>A/B测试有着广泛的应用，那么为什么要在上线新产品或者新服务的时候进行A/B测试呢？</p>
<ul>
<li><p>降低经验注意决策的风险。</p>
</li>
<li><p>降低开发维护程本。</p>
</li>
<li><p>缩短项目周期。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-3</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-3/</url>
    <content><![CDATA[<h1 id="如何测试矿泉水瓶"><a href="#如何测试矿泉水瓶" class="headerlink" title="如何测试矿泉水瓶"></a>如何测试矿泉水瓶</h1><p>一个刚生产出来的矿泉水瓶要不要进行测试（检验）？答案是肯定的，当然要进行测试。只有通过测试，才能批量生产。如果产品生产出来后不进行测试，直接交给用户使用，在用户使用时出现了问题，那势必会给用户和企业带来不良的影响，甚至是严重的后果。那么测试人员该如何针对矿泉水瓶进行测试呢？</p>
<span id="more"></span>

<p>一个从未接触过软件测试的职场新人很可能会对矿泉水瓶的测试点总结如下。</p>
<p>（1）矿泉水瓶的长度、宽度、高度和容积。</p>
<p>（2）瓶盖拧紧是否需要很大的力度。</p>
<p>（3）瓶盖内螺纹圈数、螺纹深度与样品是否一致。</p>
<p>（4）瓶盖外的摩擦阻力是否良好。</p>
<p>（5）瓶盖上的商标是否与样品要求一致。</p>
<p>（6）是否有生产日期，是否过期。</p>
<p>（7）包装是否精美，是否符合要求。</p>
<p>（8）包装是否环保。</p>
<p>（9）包装说明书是否字迹清楚，是否有错别字，是否有表达上的歧义。</p>
<p>（10）各种标识，如容积、环保性、条码、公司地址等，是否清楚、正确和规范。</p>
<p>（11）包装上的条码能否扫描。</p>
<p>（12）瓶子是否容易倾斜。</p>
<p>（13）瓶身是否光滑。</p>
<p>（14）瓶身的雕纹走向是否自然、流畅、美观，并符合要求。</p>
<p>（15）空瓶内是否有气味。</p>
<p>（16）装满开水时瓶身的变化，瓶内气味及水的味道。</p>
<p>（17）装满冷水时瓶身的变化，瓶内气味及水的味道。</p>
<p>（18）冷热参半时瓶身的变化，瓶内气味及水的味道。</p>
<p>（19）瓶子的材料是否环保，是否有环保标识。</p>
<p>（20）瓶子承受的最大压力。</p>
<p>（21）瓶子是否易燃。</p>
<p>（22）观察瓶口是否容易漏水。</p>
<p>（23）瓶口是否光滑舒适。</p>
<p>（24）装食用油后瓶身变化及瓶内气味。</p>
<p>（25）装汽油后瓶身变化及瓶内气味。</p>
<p>（26）水油混合后瓶身变化及瓶内气味。</p>
<p>（27）装醋后瓶身变化及瓶内气味。</p>
<p>（28）商标是否显眼，易于识别。</p>
<p>很容易就可以写出28个测试点，为什么能写出这么多的测试点呢？原因很简单，因为大家经常喝矿泉水，所以对矿泉水瓶的使用非常熟悉，能写出一些测试点来也不足为奇，测试有时候就是这么简单。但是对于其中一些测试点，例如“观察瓶口是否容易漏水”，这个测试点写清楚了吗？显然是没有写清楚，因为只是写出了测试的地方是瓶口，随后提出了一个问题——瓶口是否容易漏水。但是测试工作并不是提出问题，而是要用具体的方法去测试瓶口是否容易漏水。也就是说除了要写清楚测试对象外，还要写清楚如何去测试它。那么这个测试点可以这样写：用瓶子装满水之后，扭紧瓶盖，然后使劲摇晃和挤压，观察瓶口是否有水渗出。这样一来测试对象和方法都写出来了，测试点才会更加清晰。</p>
<p>按照同样的思路，可以重新修改整理一下测试点，并加入测试的方法，具体如下。</p>
<p>（1）瓶身上广告和图案的背景颜色是否符合公司的设计要求。</p>
<p>（2）瓶身上所有的字体颜色是否符合公司的设计要求，是否有错别字。</p>
<p>（3）带广告的图案遇水后是否会掉色或变模糊，广告内容与图案是否合法。</p>
<p>（4）瓶身上是否有防止烫伤、垃圾回收、年龄限制等提示。</p>
<p>（5）瓶身上图标布局是否合理，其间距、大小是否符合公司的设计要求。</p>
<p>（6）瓶子底座尺寸、高度尺寸是否符合公司的设计要求。</p>
<p>（7）瓶子的口径尺寸是否符合公司最初的设计要求。</p>
<p>（8）瓶身上的纹路及线条是否符合公司的设计要求。</p>
<p>（9）在装少量的水、装半瓶水、装满水这几种情况下，分别将水倒入准备好的量筒中，查看量筒的读数，检查矿泉水瓶的容量是否符合设计要求、装满多少水后会漏水。</p>
<p>（10）将空瓶和装满水的瓶子放在电子秤上，检查瓶子装满水前后的重量，看是否符合公司的设计要求。</p>
<p>（11）将瓶子装满水后拧紧瓶盖，将其倒置或使劲摇晃、挤压，看是否漏水。</p>
<p>（12）拧紧瓶盖后，请小孩、成年男性、成年女性分别去拧瓶盖看是否都能拧开。</p>
<p>（13）将瓶子装满水后倒入口中看能不能喝到水，是否存在漏水的现象。</p>
<p>（14）用手挤压空瓶子，挤扁后观察瓶身能否自动复原。</p>
<p>（15）分别在装水或不装水的情况下观察瓶身的透明度，看是否清澈透底。</p>
<p>（16）将空瓶、装半瓶水的瓶子、装满水的瓶子分别放在水平桌上及放在有20°和30°倾斜角度的桌面上，看瓶子是否倾斜或不稳。</p>
<p>（17）将装满水的瓶子和装半瓶水的瓶子分别放置于－10℃、－20℃、10℃、30℃、50℃、80℃、100℃的环境中，连续放1天、10天、20天、30天，然后观察瓶子是否漏水，瓶身是否破裂。</p>
<p>（18）将空瓶、装半瓶水的瓶子、装满水的瓶子分别置于太阳光下曝晒（0.5h、1h、3h、5h），观察瓶子是否漏水，瓶身是否破裂。</p>
<p>（19）将空瓶、装半瓶水的瓶子、装满水的瓶子分别从不同高度（1m、3m、8m、15m）摔下来，观察瓶身是否摔破，是否漏水。</p>
<p>（20）成年人分别使劲摔（或者是各种角度按压）空瓶、装半瓶水的瓶子、装满水的瓶子，摔一次和摔多次，看瓶子是否摔坏（漏水和破裂）。</p>
<p>（21）将空瓶、装半瓶水的瓶子、装满水的瓶子分别置于水平桌面上，用电风扇吹桌面上的瓶子，调节电风扇的风力大小，观察瓶子是否会被吹倒或吹走。</p>
<p>（22）满瓶的水加包装后，六面震动，检查产品是否能应对铁路/公路/航空等运输环境。</p>
<p>（23）将空瓶子燃烧掉，观察燃烧时的火焰，闻燃烧时的气味，查看燃烧的残留物是否符合材质的燃烧特性，是否产生有害的毒气。</p>
<p>（24）空瓶长时间放置（一个月、三个月、半年），用仪器检测是否会产生塑化剂或细菌。</p>
<p>（25）装满水后（其次可装入不同的液体，如果汁、碳酸饮料）分别放置1天、5天、10天后，检测瓶身与液体间是否发生化学反应，是否产生有毒物质或细菌。</p>
<p>（26）装入热水（50℃～100℃），分别放置1min、5min、10min，然后观察瓶子是否变形，是否有异味产生。（27）用手去抚摸瓶身的内壁和外壁，是否感觉光滑舒适不刺手。</p>
<p>（28）试着喝口水，并将瓶口在嘴中转动，感受瓶口的舒适度和圆滑度。</p>
<p>（29）用手轻拿已装满水的瓶子看是否容易掉落，检查瓶身是否有防滑措施。</p>
<p>（30）瓶子分别装入30℃、60℃、80℃的水时用手掌感受瓶身的温度，因为感受不到的话更容易烫嘴。</p>
<p>（31）分别将瓶子放入手中、口袋、包中、车上，观察是否易于携带。</p>
<p>（32）瓶中分别装入碳酸饮料（如可乐）、果汁、咖啡、茶水、油类（如菜油）等液体，放置0.5h后再倒入口中测试是否变味。</p>
<p>（33）瓶中是否可以装入固体（例如饼干、沙子，石头等），且瓶子与装入的固体是否会发生化学反应。</p>
<p>这次写出了33个测试点，比之前写的测试点详细了很多。但是在写测试点的时候，并没有预先梳理测试点，而是想到一条写一条，导致测试点的编写缺乏条理性，而且也不知道写得是否全面。那么对于一个矿泉水瓶的测试到底要基于哪些方面呢？</p>
<p>第一，瓶子的外观界面测试。</p>
<p>瓶子的外观界面测试主要是测试瓶子的大小、瓶身所体现的各种信息（如字体、颜色）等瓶子的外观特征是否满足公司最初对瓶子的设计要求，那么示例中编号为（1）、（2）、（3）、（4）、（5）、（6）、（7）、（8）的测试点就可以归到瓶子的外观界面测试当中。</p>
<p>第二，瓶子的功能测试。</p>
<p>瓶子的功能测试主要是测试瓶子的装水功能、喝水功能以及瓶子自带的一些功能特点。围绕这些特点，示例中编号为（9）、（10）、（11）、（12）、（13）、（14）、（15）的测试点都可以归到瓶子的功能测试当中。</p>
<p>第三，瓶子的性能测试。</p>
<p>瓶子的性能测试主要是测试瓶子的抗摔、抗压、抗高低温的这些情况。围绕这些特点，示例中编号为（16）、（17）、（18）、（19）、（20）、（21）、（22）的测试点都可以归到瓶子的性能测试当中。</p>
<p>第四，瓶子的安全性测试。</p>
<p>瓶子的安全性测试主要是测试瓶子在使用过程中瓶子本身是否会对人体或环境造成一些伤害，是否存在潜在的安全问题。围绕这些特点，示例中编号为（23）、（24）、（25）、（26）的测试点都可以归到瓶子的安全性测试当中。</p>
<p>第五，瓶子的易用性测试。</p>
<p>瓶子的易用性测试主要是测试瓶子用起来是否方便，例如拿在手上或装在包里是否方便等，如果瓶子设计得太复杂估计就没有多少人用了。围绕这些特点，示例中编号为（27）、（28）、（29）、（30）、（31）的测试点都可以归到瓶子的易用性测试当中。</p>
<p>第六，瓶子的兼容性测试。</p>
<p>瓶子的兼容性测试主要是测试瓶子除了可以装水之外，是否还可以装一些其他的东西，例如其他液体或固体等。围绕这些特点，示例中编号为（32）、（33）的测试点都可以归到瓶子的兼容性测试当中。</p>
<p>将测试点进行这样的简要划分后，编写测试点时就会更加清晰、有条理了。当然不一定非要这样划分，只是想告诉读者对一个产品做通用测试的时候，最初是可以基于产品的外观界面、功能、性能、安全性、易用性、兼容性这6个方面进行测试的，而事实上这6个方面也是必须要测试的。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-4</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-4/</url>
    <content><![CDATA[<h1 id="项目成员，项目需求评审"><a href="#项目成员，项目需求评审" class="headerlink" title="项目成员，项目需求评审"></a>项目成员，项目需求评审</h1><h1 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h1><p>先了解一下软件项目中所涉及到的一些重要角色和关键词，分别是 项目，项目经理，需求，用户，开发人员，测试人员和产品人员。</p>
<p>项目： 代表软件研发的项目，包括了从前期项目预研，立项，组建项目团队，设计开发软件，测试调试，交付验收，以及软件运营等各项具体的工作。</p>
<p>项目经理：软件项目的总负责人。项目经理既需要广泛的计算机知识，又需要项目管理技能，能够对项目的成本，人力，进度，质量，风向，安全等进行准确的分析和管理。从而使项目按照计划顺利完成。</p>
<p>需求: 用户需求，有了需求，才有项目，开发人员根据需求开发对应的产品。</p>
<p>用户：这里一般指的是提出需求的用户，同时软件验收的主要人员。</p>
<p>开发人员： 软件项目组中负责研发的技术人员。</p>
<p>测试人员：软件项目组中负责测试的人员。</p>
<p>产品人员：负责产品的设计，需求分析整理等工作。</p>
<span id="more"></span>



<img align ="center" src = "https://pic.imgdb.cn/item/610103d65132923bf861965d.png" />

<h1 id="评审需求文档"><a href="#评审需求文档" class="headerlink" title="评审需求文档"></a>评审需求文档</h1><img align ="center" src = "https://pic.imgdb.cn/item/610103d65132923bf8619672.png" />



<ol>
<li><p>需求文档是一个文字描述性的文档，开发和测试在阅读的时候可能会有不同的理解，所以需要 产品，测试，开发三方人员进行评审。</p>
</li>
<li><p>评审的方式一般是：</p>
<p>a) 产品经理对着需求文档的内容一一讲解，然后解释其中的意思。</p>
<p>b) 测试，开发针对一些自己理解不一致的需求进行提问，提出自己的建议。</p>
<p>c) 产品人员最终决定。</p>
<p>d) 最后形成一个标准的，统一的需求文档</p>
</li>
</ol>
<h2 id="如何评审需求文档"><a href="#如何评审需求文档" class="headerlink" title="如何评审需求文档"></a>如何评审需求文档</h2><ul>
<li>正确性:  对照原始的需求，检查产品人员制定的文档是否偏离了最原始的用户需求。</li>
</ul>
<ul>
<li>明确性：检查需求文档中是否包含一些含糊其辞的词汇，比如 <code>过多</code> ， <code>过少</code> ， <code>适量</code> , <code>是否</code> 。检查用语是否清晰，无歧义。</li>
</ul>
<ul>
<li>完整性：对照原始的需求文档，检查产品人员制定的需求文档是否完全覆盖用户所有的需求点。</li>
</ul>
<ul>
<li>限制性：每个需求中是否清晰描述了这个软件能做什么，不能做什么，什么能输入，什么不能输入。</li>
</ul>
<ul>
<li>优先级：需求文档中哪些文档比较重要，哪些不重要，要有优先级。</li>
</ul>
<ul>
<li>一致性： 检查需求文档中的内容是否前后一致，确保不冲突，不矛盾。</li>
</ul>
<h1 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h1><ol>
<li>测试工作是从什么时候开始的？</li>
</ol>
<p>参考回答： 我之前工作的单位，在做测试工作的时候，我们一般在拿到需求文档的时候就开始了。</p>
<ol>
<li>需求评审的目的是什么？</li>
</ol>
<p>参考回答:  我觉得需求评审的目的主要是消除歧义，完善细节，最后达成共识，如果不进行评审，就意味着开发人员和测试人员可能会对需求文档的理解存在偏差，最终可能导致产品的质量不符合需求文档要求。</p>
<ol>
<li>你是如何评审需求文档的？</li>
</ol>
<p>参考回答： 我们公司之前评审需求的时候， 主要是从6个方面进行的… (参考上文)。</p>
<p>基本上，我们会从这6方面来进行评审，当然每个公司的评审机制可能会有一些差异，但是主要目的就是把需求文档的细节理解清楚，达成共识，谢谢。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-5</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-5/</url>
    <content><![CDATA[<h1 id="软件测试的流程"><a href="#软件测试的流程" class="headerlink" title="软件测试的流程"></a>软件测试的流程</h1><p>软件测试的流程大致分为测试计划与控制、测试分析与设计、测试实现与执行、测试评估与报告和测试结束活动。在实际工作中，大多企业把测试工作分为五个阶段：</p>
<ul>
<li><p>测试计划阶段、</p>
</li>
<li><p>测试设计阶段、</p>
</li>
<li><p>测试实现阶段、</p>
</li>
<li><p>测试执行阶段、</p>
</li>
<li><p>测试总结。</p>
</li>
</ul>
<p>在熟悉流程前，我们首先看一下，测试组织中的角色与职责。</p>
<span id="more"></span>

<h1 id="测试角色与职责"><a href="#测试角色与职责" class="headerlink" title="测试角色与职责"></a>测试角色与职责</h1><p>在工作中测试组织结构通常涉及的人员有：测试经理（TM）、测试工程师（TE）。</p>
<h2 id="测试经理"><a href="#测试经理" class="headerlink" title="测试经理"></a>测试经理</h2><p>测试经理在公司主要负责公司测试的组织和管理工作，要确保在给定的时间、资源和费用的限制下进行设计测试项目的管理，定期向公司高层领导汇报工作。测试经理在适当的时候也需要参与项目的分析和讨论。通常比较大的企业会设有测试经理这一岗位，一些小的企业该职位一般由IT部领导或QA主管来担任。</p>
<h2 id="测试工程师"><a href="#测试工程师" class="headerlink" title="测试工程师"></a>测试工程师</h2><p>测试工程师主要负责执行测试分析员建立的测试设计，将测试结果记录到文档中。在测试执行前，需要建立测试环境，包括测试数据的准备以及其他支持测试所需的软件（模拟器和测试辅助程序）。在测试执行过程中，需要记录用例执行的状态，便于后期的跟踪和维护。在测试执行完成后，将所发现的Bug提交到缺陷管理工具上，便于后期的回归测试活动。在整个项目完成后，对相应的Bug（遗漏缺陷）进行分析，并形成缺陷报告文档提交给项目测试经理，并协助项目测试经理完成最终的测试报告。</p>
<h1 id="测试计划与控制"><a href="#测试计划与控制" class="headerlink" title="测试计划与控制"></a>测试计划与控制</h1><p>测试计划阶段需要根据项目计划、需求规格说明书以及开发计划来制定测试计划，按照不同的测试阶段设计相应的测试计划。它的主要目的是明确组织形式、测试对象、定义测试通过/失败的准则、测试挂起/恢复的准则、测试风险的防范措施、合理分配测试任务以及测试交付的工作产品等。在实际工作中，测试计划一般由项目测试经理或项目测试组长来负责制定，测试人员需要参与测试计划的制定及评审活动。常见的测试计划内容如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601900480730-e2ba9b96-90f5-4c42-a269-a2c535166904.png" alt="img"></p>
<h1 id="测试分析与设计"><a href="#测试分析与设计" class="headerlink" title="测试分析与设计"></a>测试分析与设计</h1><p>测试设计阶段就是将测试计划阶段制定的测试需求进行细化分解为若干个可执行的测试过程，主要体现在测试策略、测试方法的选取以及测试规程的设计上，也就是如何编写测试方案。测试计划解决的是做什么，而测试方案就是解决怎么测试，如何进行测试。通常根据不同阶段（单元测试、集成测试、系统测试、验收测试）的被测对象以及每个阶段所要进行的测试类型（功能测试、性能测试、安全性测试、可靠性测试以及兼容性测试等）的不同，可能会采用不同的测试策略。测试方案主要是对测试需求进行细化，分析测试用例设计方法，规划测试环境以及对测试工具的选取等。常见的测试方案内容如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601900534924-1d3a8911-3d18-4186-9ec0-0b20dbbab3f9.png" alt="img"></p>
<h1 id="测试实现与执行"><a href="#测试实现与执行" class="headerlink" title="测试实现与执行"></a>测试实现与执行</h1><p>测试实现阶段主要根据测试方案设计来完成：测试脚本的开发、测试用例的写作。测试脚本通常用在自动化测试和性能测试中，根据自动化测试的目标、性能测试场景来开发相应的测试脚本。测试用例主要用来指导测试执行，可以根据用例设计的方法来进行设计，针对不同的阶段选择方法也不一样，白盒测试用例设计方法主要有逻辑覆盖法、基本路径法等；</p>
<p>黑盒测试用例设计方法主要有等价类划分法、边界值分析法、流程设计法、判定表分析、因果图分析法、正交试验法、错误推测法以及异常处理等。</p>
<p>通用的测试用例格式如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601900576282-6e063622-d5e6-4f71-9a01-953264d752db.png" alt="img"></p>
<p>测试执行前，首先根据项目的测试情况来搭建测试环境，一般有自动化测试环境、手工测试环境以及性能测试环境等。在测试中为了使得测试结果的数据更接近用户，应尽量模拟用户的实际环境来进行搭建。</p>
<p>其次根据测试的不同阶段，在执行前的准备也不同。比如性能测试，在执行性能测试前需要进行测试数据的准备阶段。又如系统测试，在执行测试前需要进行预测试。</p>
<p>预测试又称为冒烟测试，即利用较短时间快速验证软件系统的基本功能，主要是指核心业务以及风险比较高的功能，以确保后期的系统测试能够顺利进行。通常预测试执行的时间控制在2～3小时内，最多不超过一天。预测试的用例可以从已经写好的并且优先级比较高的用例中，抽取10%作为预测试的用例，也可以重新设计预测试用例。一般预测试的标准是预测用例的90%全部通过。</p>
<p>在执行测试阶段中，应严格按照测试计划进行；也可以根据项目的进度安排，按照用例的优先级进行测试。执行的过程中，需要注意缺陷的记录（截图、错误日志的消息等）。在实际工作中，测试工程师在执行时，每天要写测试日报记录发现的问题以及执行中遇到的困难和问题，还需要实时把缺陷记录到缺陷管理工具中，便于后期的进行跟踪、管理。待开发修复缺陷以后还要进行回归测试。</p>
<h1 id="测试评估与报告"><a href="#测试评估与报告" class="headerlink" title="测试评估与报告"></a>测试评估与报告</h1><p>测试工程师根据缺陷的记录，进行分析与评估。主要分析缺陷的分布、密度以及发展趋势，还要分析软件在整个研发过程中引发缺陷的根本原因。最后编写缺陷报告，以便协助完成测试报告，为软件产品的质量提供真实的数据依据。</p>
<p>通用的缺陷报告内容如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601900731815-ea767f37-265e-407c-8658-2aa70915292f.png" alt="img"></p>
<p>通用的测试报告内容如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601900752052-8c0e3407-cba2-416a-8af4-ac1e7c2e804f.png" alt="img"></p>
<h1 id="测试结束活动"><a href="#测试结束活动" class="headerlink" title="测试结束活动"></a>测试结束活动</h1><p>在测试执行全部完成后，并不意味着测试项目的结束。除了测试报告的写作之外，还要对测试中涉及的所有文档、数据及相关的资料进行整理归档。通常测试结束需要检查以下内容：</p>
<ul>
<li><p>对测试项目进行全过程、全方位的审视，检查测试用例是否全部执行，检查测试是否有遗漏。</p>
</li>
<li><p>检查有没有未解决的各种问题，对项目存在的缺陷逐个进行分析，了解对项目质量影响的程度，从而决定整个测试过程是否可以告一段落</p>
</li>
<li><p>检查测试报告是否达到产品质量已定义的标准，是否符合测试结束的标准以及对测试产出的风险记录进行评估，最终将测试报告定稿。</p>
</li>
<li><p>在测试结束后，通过对项目中的问题进行分析，找出流程、技术或管理中所存在的问题根源，将相关的经验教训进行总结并分享到项目组以及整个公司中，避免以后发生类似的错误。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-7</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-7/</url>
    <content><![CDATA[<h1 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h1><p>什么是测试用例呢？测试用例对测试工作会起到怎样的作用呢？测试用例与需求文档之间存在什么样的关系呢？</p>
<span id="more"></span>

<h1 id="测试用例的格式"><a href="#测试用例的格式" class="headerlink" title="测试用例的格式"></a>测试用例的格式</h1><p>在前面的内容里已经为矿泉水瓶设计了33个测试点，然后依据这些测试点来测试矿泉水瓶。其实在软件测试领域，这个测试点指的就是测试用例。接下来一起来看看如何把一个测试点一步步演变成测试用例，下面举例说明</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601993252736-e0796f25-46cd-41ca-a690-432edb24c5db.png" alt="img"></p>
<p>如果现在要对这个登录模块进行功能测试，那应如何测试呢？以下4个测试点是某同学在没有任何测试经验的情况下想出来的。</p>
<p>（1）输入正确的用户名和错误的密码测试能否登录成功。</p>
<p>（2）输入错误的用户名和错误的密码测试能否登录成功。</p>
<p>（3）用户名和密码都不输入的情况下测试能否登录成功。</p>
<p>（4）输入正确的用户名和正确的密码测试能否登录成功。</p>
<p>针对以上4个测试点，从中任选一个测试点来分析一下，例如直接选择第一个测试点：输入正确的用户名和错误的密码测试能否登录成功。单从字面上看，这个测试点似乎写得很清楚，输入正确的用户名，然后再输入错误的密码，之后看能不能登录邮箱。事实真的如此简单吗？</p>
<p>第一个问题，“输入正确的用户名和错误的密码测试能否登录成功”，这个测试点是针对邮箱的哪个模块进行测试的呢？在测试点中没有明确说明。</p>
<p>第二个问题，测试时如果网络不通畅，是无法进行这个登录测试的，所以测试前提条件就是要保证网络通畅，这一点也没有在测试点中说明。</p>
<p>第三个问题，邮箱登录功能是在什么环境下测试的呢？是在Mac操作系统上还是在Windows 10操作系统上测试的，用的是Safari浏览器还是Chrome浏览器，具体的测试环境在测试点中没有说明。</p>
<p>第四个问题，在输入用户名和密码前，测试人员是通过什么网址打开登录页面的，这一点在测试点中也没有说明。</p>
<p>第五个问题，输入正确的用户名和错误的密码，那么这个正确的用户名和错误的密码具体的测试数据是什么呢？这个在测试点中也没有明确出来。</p>
<p>第六个问题，“输入正确的用户名和错误的密码测试能否登录成功”，对测试人员而言是期望它登录成功还是登录失败呢？这在测试点中也没有明确写清楚。</p>
<p>对于以上几点，有人会说，我当然清楚这里面相关的测试数据和判断。可如果软件的测试点多达成百上千个时，你真能记得住这些测试点的每个测试步骤和测试数据吗？所以测试人员在最初设计测试点时，一定要把<strong>测试所针对的模块、测试的前提条件、测试所用到的环境、测试的具体步骤、测试步骤中所用到的具体测试数据以及测试人员想到得到一个什么样的预期结果</strong>等这些关键元素写清楚，以便在后期执行测试用例时能够顺利进行。结合以上几点，便可对“输入正确的用户名和错误的密码测试能否登录成功”这个测试点进行完善，具体内容如下。</p>
<p>此测试点针对的是某邮箱的登录模块，测试之前，确保网络是通畅的。首先在Windows 10操作系统中打开IE11浏览器，并在浏览器网址中输入该邮箱登录页面的网址<a href="http://mail.***.com，然后打开邮箱的登录页面，接着在用户名输入框中输入一个正确的用户名“test123”，在密码输入框中输入一个错误的密码“123456”，单击登录按钮，查看是否登录成功。测试人员期望的结果：邮箱登录不成功，并提示用户名和密码错误。">http://mail.***.com，然后打开邮箱的登录页面，接着在用户名输入框中输入一个正确的用户名“test123”，在密码输入框中输入一个错误的密码“123456”，单击登录按钮，查看是否登录成功。测试人员期望的结果：邮箱登录不成功，并提示用户名和密码错误。</a></p>
<p>这样编写测试点后，就细致了很多，因为测试的关键元素都被写出来了。依据这个测试点的描述，即使不是测试人员，也能顺利执行。但这里有一个问题，如果每个测试点都写成一段话，那么登录模块的所有测试点会像是一篇文章，写的时候费力，读的时候也费时，无形地增加工作量。为了增强测试点的可写性和可读性，可以把一个测试点所必须包含的内容划分成9个基本元素，并通过表格的形式将它们展示出来</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601993570352-7ee8c2c9-1b5c-4887-8b4e-b660a0b23e25.png" alt="img"></p>
<p>（1）从上表可以看到，这9个基本元素分别是测试序号、测试模块、前置条件、测试环境、操作步骤和数据、预期结果、实际结果、是否通过、备注。而原先测试点中的内容也被相应地分割，并把分割后的内容放置在了相对应的元素下面，这就构成了一个标准的测试用例。</p>
<p>（2）测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便核实是否满足某个特定需求。测试用例是测试的一个例子，而这个例子包括测试序号、测试模块、前置条件、测试环境、操作步骤和数据、预期结果、实际结果、是否通过、备注这9个关键的基本元素。每个公司的规范可能不一样，有的还包括测试时间、测试人员、软件的版本名称、优先级等一些附加元素。</p>
<p>（3）接下来再把前面所写的第二个测试点“输入错误的用户名和错误的密码测试能否登录成功”也转化为表格形式的测试用例。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601993690994-15e121aa-6c2f-4614-a015-cd835fe74d50.png" alt="img"></p>
<p>（4）从表2可以看到第二个测试点也已转化为表格形式，转化的过程其实很容易，就是把测试用例的内容依次填写到相应的表格中。通过以上的表格形式来编写测试用例，测试用例中各个元素信息一目了然，使得用例的编写、阅读和执行更加容易。</p>
<p>（5）其中“操作步骤和数据”是测试用例中最关键的地方，结合表2中的第二个测试用例，观察一下操作步骤和数据的演变过程。如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601993855655-56635da3-6d07-4b5f-8f2d-510ee79c72f7.png" alt="img"></p>
<p>通过图中3个测试步骤的对比，最后一个操作步骤和数据是最详细的，不仅加入了如何打开邮箱登录页面的步骤，还加入了用户名和密码的详细信息。那么对于初级软件测试人员而言，测试步骤和数据一般要细致到什么程度呢？在实际的工作中，对初级软件测试人员曾有这么一个标准，<strong>即如果你写出来的测试步骤和数据能够让一个从未接触过测试工作的普通人也能顺利执行的话，那么说明这个测试步骤和数据就写得很详细了。待有一定的工作经验后，测试用例的操作步骤可以适当简化，但简化之后也要清晰明了，具体的测试数据也是不能少的。</strong></p>
<p>（6）“预期结果”是测试用例中的第二个关键元素，结合表6-2中的第二个测试用例，也来观察下预期结果的演变过程。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601993973792-269048cc-2443-4494-8b6a-97e47750a9fe.png" alt="img"></p>
<p>通过图3中3个预期结果的对比，最后一个预期结果是最全面的。其实核心的预期结果只有一个：邮箱登录不成功，并提示用户名和密码错误。但严格来讲，每个测试步骤都应该有一个预期结果。例如在第二个测试用例中，操作步骤和数据中一共有3个步骤，那么预期结果也应该有3个，对于初级软件测试人员来说，应当尽可能地把每个操作步骤所对应的预期结果写完整。当然，写出操作步骤，就很好写预期结果了，除非测试人员不熟悉测试系统或需求文档。</p>
<p>接下来，再把前面所写的第三个测试点“用户名和密码都不输入的情况下测试能否登录成功”和第四个测试点“输入正确的用户名和正确的密码测试能否登录成功”都转化为表格形式的测试用例。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601994082709-d9a43a3e-dac5-42bb-a7fc-cfcc4ac134b4.png" alt="img"></p>
<p>（7）对于测试用例的“实际结果”这一元素，在实际测试软件时才能填写。例如针对测试点“输入正确的用户名和错误的密码测试能否登录成功”，如果执行测试用例的时候发现邮箱是登录失败的，那么该测试用例的实际测试结果就是“登录失败”。</p>
<p>（8）对于测试用例的“是否通过”这一元素，它指的是如果实际结果与预期结果相符，则表明此测试用例通过；如果实际结果与预期结果不相符，则表明此测试用例不通过，说明程序的处理是有问题的，需要测试人员提交Bug单给开发人员进行修改。</p>
<p>（9）对于测试用例的“备注”这一元素，指的是对本测试用例额外补充的一些说明，如无特殊情况，这个选项一般可以不填。</p>
<p>至此，已介绍完测试点演变成测试用例的整个过程了。通俗来讲，测试点就是一个测试用例的中心思想，或者说测试点就是设计测试用例的大纲；而测试用例是在测试点的基础上进一步细化了其中的内容。在实际的工作中，测试人员可采用Excel表格或者是Word文档来编写测试用例，也可以使用相应的测试管理工具编写。</p>
<h1 id="测试用例的作用"><a href="#测试用例的作用" class="headerlink" title="测试用例的作用"></a>测试用例的作用</h1><p>开发人员在拿到通过评审的需求文档后，就会按照需求文档进行概要设计和详细设计的工作，然后再进入编码阶段，在开发人员进行软件开发的这段时间里，测试人员会设计出各模块的测试用例。待开发人员开发完成软件之后，测试人员就可以依据之前设计好的测试用例测试软件是否有问题，而不是等开发软件完成后，测试人员再去设计测试用例。</p>
<p>测试用例是测试人员具体执行测试的依据，它是非常关键的文档，它作为测试的标准并指导测试人员进行测试工作。测试人员会按照测试用例中的操作步骤和具体数据逐一执行测试用例，发现问题并提交Bug单，最终完善软件的质量。</p>
<h1 id="测试用例与需求的关系"><a href="#测试用例与需求的关系" class="headerlink" title="测试用例与需求的关系"></a>测试用例与需求的关系</h1><p>在前面的内容里，设计矿泉水瓶测试点时，放置了矿泉水瓶这个明显的参照物在测试人员面前，所以测试点设计起来就比较容易。但测试人员在设计软件测试用例时，这个软件并没有完成开发，没有明显的参照物可以给到测试人员，那此时测试人员是依据什么来设计测试用例的呢？其实测试人员是依据需求文档来进行测试用例的设计的。</p>
<p>需求文档包含了软件的所有需求规格，包括功能需求和非功能需求（例如性能安全方面的需求）等，其信息量很大，可能大部分的需求内容是初级软件测试人员暂时不涉及的，过早的展示会影响测试人员的学习理解。而初级软件测试人员需要关注的是需求文档里每个功能模块的需求，因为初级软件测试人员主要做的是功能测试。接下来，就选取某需求文档中的一个片段，该片段描述的是某网站登录模块的功能需求说明。</p>
<p>（1）功能描述：对用户进行身份验证，只有输入了正确的用户名和密码的用户才能成功登录到网站首页；当输入错误的用户名或密码时，则无法登录到网站首页，并会给出相应的提示信息。</p>
<p>（2）该网站登录原型界面如图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601994482388-ffe8d854-c36a-42ec-ac21-46c908d83d19.png" alt="img"></p>
<p>（3）输入项：登录模块的输入项包括用户名输入框、密码输入框、确认登录按钮。</p>
<p>（4）输出项：登录模块的输出项有两个情景，一个是成功登录到网站首页，另一个登录失败时的提示信息。</p>
<ul>
<li>① 登录成功：用户直接进入到网站首页。</li>
<li>② 登录失败：系统将给出提示的信息</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601994553197-6e772a52-1a84-4e6f-8db4-082e6654db52.png" alt="img"></p>
<p>（5）输入框限制：用户名和密码的取值范围</p>
<p>   <img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601994596989-5adbfb8a-21e8-48e3-9308-18b451d0a577.png" alt="img"></p>
<p>上面的需求项似乎有点多，把以上的需求项整合一下就变成了如下图的形式，这样就清晰了很多。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601994669833-46c230e7-7aa7-46d6-81ec-48368afb8997.png" alt="img"></p>
<p>在这里只展示了登录模块的功能需求，需求文档会对软件中每个模块的功能都进行相应的需求说明，这些说明包括每个模块的功能描述、原型界面、输入项、输出项、数据的取值范围等信息，所以测试人员不用担心没有“参照物”。</p>
<p>有了需求文档这一详细的“参照物”后，测试人员就有了设计测试用例的依据。（补充一点：正如前文所述，工作中如发现需求文档中有不详细或存在歧义的地方，要及时与产品人员沟通确认。）</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-8</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-8/</url>
    <content><![CDATA[<h1 id="用例设计的基本思路"><a href="#用例设计的基本思路" class="headerlink" title="用例设计的基本思路"></a>用例设计的基本思路</h1><p>用例设计的基本思路在实际工作中，稍微大型一点的软件系统一般都包括用户注册、登录、搜索以及附件上传等常见模块。本节就以这些模块为例，结合已介绍过的用例设计方法来分别讲解这些模块的设计思路。</p>
<span id="more"></span>

<h1 id="QQ邮箱注册模块"><a href="#QQ邮箱注册模块" class="headerlink" title="QQ邮箱注册模块"></a>QQ邮箱注册模块</h1><p>由于QQ邮箱大家都比较熟悉，其用户体验也做得很好，接下来就以QQ邮箱注册模块（简化版）为例来分析一下它的测试思路。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601995150830-7e6efe79-5fa6-45a2-8449-c2ab781ebdb2.png" alt="img"></p>
<h2 id="一-此注册模块的需求文档"><a href="#一-此注册模块的需求文档" class="headerlink" title="一. 此注册模块的需求文档"></a>一. 此注册模块的需求文档</h2><p>邮箱名：由3～18个英文字符、数字、点、减号、下划线组成。昵称：中英文字符，不能为空。密码：长度为6～18位，不能为空，至少包括英文、数字、符号中的2种。</p>
<h2 id="二-基本功能的测试点分析"><a href="#二-基本功能的测试点分析" class="headerlink" title="二. 基本功能的测试点分析"></a>二. 基本功能的测试点分析</h2><p>从图中可以看到QQ邮箱的注册页面为3个字符输入框。上文介绍过对于多个输入框的测试可以采用正交表法。基于正交表的设计思想，可以设计出以下组合的测试点</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601995438349-69050b62-c787-405a-bcd6-eaca555e6f2d.png" alt="img"></p>
<p>针对每一个输入框，还需要利用等价类划分法、边界值分析法以及错误推测法设计正确和错误的测试数据分别对邮箱名、昵称、密码输入框进行测试。</p>
<p>实际工作中，可以将输入框测试的测试数据合理地设计到上表中，即在利用正交表测试输入框组合时，同时进行输入框测试。</p>
<p>例如，对于表中的第二行组合，需要输入正确的邮箱名、错误的昵称、错误的密码。那么这个正确邮箱名的测试数据，可以从邮箱名的有效等价类中选一个（如<a href="mailto:&#x74;&#x65;&#x73;&#116;&#95;&#x31;&#x32;&#x33;&#x2d;&#97;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;">&#x74;&#x65;&#x73;&#116;&#95;&#x31;&#x32;&#x33;&#x2d;&#97;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#109;</a>）；错误昵称的测试数据，可以从昵称的无效等价类中选一个（如@@@）；同理，错误密码的测试数据，可以从密码的无效等价类，或者从边界值中不符合需求的测试数据中选取（如取五位密码12345），那么第二行组合的用例可以设计为如下表，这样在进行组合测试时，就已经对每个输入框的某些测试点进行了测试。</p>
<p>在本例中，QQ邮箱注册模块的功能测试用例其实就是将邮箱名的用例、昵称的用例、密码的用例合理地组合起来，通过如表的组合设计，覆盖所有的测试点。本测试用例的设计主要考察测试人员对常用用例设计方法的运用能力。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601995528070-78402970-77e0-4485-bdf3-2bf93eaf0154.png" alt="img"></p>
<h1 id="QQ邮箱登录模块"><a href="#QQ邮箱登录模块" class="headerlink" title="QQ邮箱登录模块"></a>QQ邮箱登录模块</h1><p>登录操作是QQ邮箱最常用的功能之一，使用QQ邮箱首先要登录，登录成功才能对邮箱系统进行操作。接下来本书就以QQ邮箱的登录模块（简化版）为例来分析一下它的测试思路，如图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601995622027-61ccd31a-6480-4f63-817c-0136e29aa3a5.png" alt="img"></p>
<h2 id="一-登录模块的需求文档"><a href="#一-登录模块的需求文档" class="headerlink" title="一 登录模块的需求文档"></a>一 登录模块的需求文档</h2><p>账号：由3～18个英文字符、数字、点、减号、下划线组成。密码：6～18位，不能为空，至少包括英文、数字、符号中的2种。</p>
<h2 id="二-基本功能的测试点分析-1"><a href="#二-基本功能的测试点分析-1" class="headerlink" title="二 基本功能的测试点分析"></a>二 基本功能的测试点分析</h2><p>下图可以看到QQ邮箱的登录页面主要由用户名和密码这两个输入框组成，同样可以利用正交表分析法来设计。表中列出了用户名和密码输入框的各种测试组合。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601995685713-2051c8b3-ce5d-4b9e-ad79-a2774ba93427.png" alt="img"></p>
<p>（1）测试输入正确用户名和正确密码的组合：可以在用户名的有效等价类中选择一个正确的用户名作为测试数据，在密码输入框中输入与用户名对应的一个正确密码。</p>
<p>（2）测试输入正确用户名和错误密码的组合：可以在用户名的有效等价类中选择一个正确的用户名作为测试数据，同理从密码的无效等价类、边界值分析法和错误推测法中选择不符合需求文档或错误的密码作为测试数据。</p>
<p>（3）测试输入错误用户名和正确密码的组合：可以在密码的有效等价类中选择一个正确的密码作为测试数据，然后从用户名的无效等价类、边界值分析法和错误推测法中分别选择不符合需求的用户名或与密码不匹配的错误用户名作为测试数据。</p>
<p>（4）测试输入错误用户名和错误密码的组合：可以从用户名、密码的无效等价类，边界值分析法和错误推测法中分别选择不符合需求的用户名和密码作为测试数据。</p>
<p>在本例中，QQ邮箱登录模块的功能测试用例就是将用户名的用例、密码的用例合理地组合起来，通过上表的组合设计，覆盖所有的测试点。本例的用例设计主要考察测试人员对常用用例设计方法的运用能力。</p>
<h1 id="QQ邮箱邮件搜索模块"><a href="#QQ邮箱邮件搜索模块" class="headerlink" title="QQ邮箱邮件搜索模块"></a>QQ邮箱邮件搜索模块</h1><p>搜索功能也是QQ邮箱比较常用的功能，对搜索模块来说，测试人员又该如何测试呢？接下来就以QQ邮箱的搜索模块（简化版）为例来分析一下搜索模块的基本测试思路，如图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601995802311-660d41b0-f29c-40d1-9860-3b6346d01f7b.png" alt="img"></p>
<h2 id="一-关键字搜索的需求文档"><a href="#一-关键字搜索的需求文档" class="headerlink" title="一 关键字搜索的需求文档"></a>一 关键字搜索的需求文档</h2><p>（1）支持模糊匹配和完全匹配、支持搜索框记忆功能、支持全角搜索、不支持同音字或错别字搜索、不区分字母大小写、支持特殊符号的搜索、支持常用快捷键、支持含有空格的搜索、支持中英文数字的混合搜索、不输入任何字符搜索时则显示全部内容、支持超长字符串搜索。</p>
<p>（2）没有限定关键字的长度。</p>
<p>（3）搜索的位置：全部内容，包括邮件地址、邮件标题、正文、附件名、草稿箱、发件箱等。</p>
<h2 id="二-基本功能的测试点分析-2"><a href="#二-基本功能的测试点分析-2" class="headerlink" title="二 基本功能的测试点分析"></a>二 基本功能的测试点分析</h2><p>本例需求的细节项较多，那么测试人员就需要针对这些细小的需求项进行用例设计；其次搜索框毕竟还是一个输入框，所以对各种字符的处理能力也是测试的一个关键。对搜索输入框设计测试用例的思路，可以借鉴前面学习过的字符输入框对字符的处理过程。接下来，本书列举了搜索框常见的测试点，以下的测试点都是初级软件测试人员能理解的。</p>
<h3 id="第一，正常情况下的搜索。"><a href="#第一，正常情况下的搜索。" class="headerlink" title="第一，正常情况下的搜索。"></a>第一，正常情况下的搜索。</h3><p>（1）把邮件地址的部分内容或全部内容（模糊匹配和完全匹配）作为关键字进行搜索，可搜索出内容。</p>
<p>（2）把邮件主题的部分内容或全部内容（模糊匹配和完全匹配）作为关键字进行搜索，可搜索出内容。</p>
<p>（3）把邮件正文的部分内容和全部内容（模糊匹配和完全匹配）作为关键字进行搜索，可搜索出内容。</p>
<p>（4）把附件名称的部分内容和全部内容（模糊匹配和完全匹配）作为关键字进行搜索，可搜索出内容。</p>
<p>（5）输入不存在的内容进行搜索，搜索结果为空。</p>
<p>（6）搜索结果为空时应给出相应提示。</p>
<p>（7）输入曾搜索过的关键字进行搜索时，搜索框应该给出记忆的功能。</p>
<h3 id="第二，各种异常情况下的搜索。"><a href="#第二，各种异常情况下的搜索。" class="headerlink" title="第二，各种异常情况下的搜索。"></a>第二，各种异常情况下的搜索。</h3><p>（1）不输入任何字符进行搜索，显示为全部内容。</p>
<p>（2）搜索的关键字中包含全半角混合字符，可以搜索出内容。</p>
<p>（3）搜索的关键字中包含有同音字或错别字，不能搜索出内容。</p>
<p>（4）搜索的关键字中包含各类特殊符号，可以搜索出内容。</p>
<p>（5）搜索的关键字中包含大小写字母，可以搜索出内容。</p>
<p>（6）搜索的关键为中文英文数字混合并且每个字符的前后都加了空格，可以搜索出内容。</p>
<p>（7）输入关键字为“0”进行搜索，可以搜索出内容。</p>
<p>（8）关键字中带有单引号进行搜索，可以搜索出内容。</p>
<p>（9）输入超长字符串进行搜索，可以搜索出内容。</p>
<h3 id="第三，测试搜索框对快捷键的支持。"><a href="#第三，测试搜索框对快捷键的支持。" class="headerlink" title="第三，测试搜索框对快捷键的支持。"></a>第三，测试搜索框对快捷键的支持。</h3><p>（1）在输入结束后，按“Enter”键后系统应该可以进行搜索处理。</p>
<p>（2）支持使用“Tab”键。</p>
<p>（3）支持“Ctrl+C”“Ctrl+V”组合键。</p>
<h3 id="第四，可以尝试一下随意性的、无规则的测试（也叫探索性测试）"><a href="#第四，可以尝试一下随意性的、无规则的测试（也叫探索性测试）" class="headerlink" title="第四，可以尝试一下随意性的、无规则的测试（也叫探索性测试）"></a>第四，可以尝试一下随意性的、无规则的测试（也叫探索性测试）</h3><p>因为无规则的测试也可能会发现软件中的一些Bug。在本例中，QQ邮箱搜索模块的功能测试用例就可以依据以上四部分用例的测试思想进行设计。</p>
<p>对于一个初级软件测试人员，由于受经验和技术所限，刚开始可能无法设计出那么多的用例，这个很正常，最重要的一点是找准搜索框的需求文档并尽可能地去挖掘更多的需求细节（或向产品经理去求证更多的需求细节），然后再针对这些需求细节才能设计出更为完整的用例来，所以挖掘需求细节是一个初级软件测试人员能设计好测试用例的一个重要因素。</p>
<p>那么本例的测试用例设计主要考察测试人员发散思维能力和挖掘需求的能力。</p>
<h1 id="QQ邮箱附件上传功能"><a href="#QQ邮箱附件上传功能" class="headerlink" title="QQ邮箱附件上传功能"></a>QQ邮箱附件上传功能</h1><p>附件上传也是QQ邮箱比较常用的功能，那么测试人员该如何对附件上传进行测试呢？接下来还是以QQ邮箱的附件上传模块（简化版）为例分析一下其基本的测试思路（只测附件上传功能），如图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601996187735-25309d60-d12d-4941-990c-db07956bd515.png" alt="img"></p>
<h2 id="一-附件上传的需求文档"><a href="#一-附件上传的需求文档" class="headerlink" title="一 附件上传的需求文档"></a>一 附件上传的需求文档</h2><p>（1）用户上传的文件可包含图片格式的文件、常见的文档、压缩文件这3类，见表</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601996230072-f9db2038-6f94-4233-babb-33683d12a767.png" alt="img"></p>
<p>（2）用户一次最多可上传10个附件，单个附件的容量不能超过1GB，多个附件的容量不能超过5GB。</p>
<h2 id="二-基本功能的测试点分析-3"><a href="#二-基本功能的测试点分析-3" class="headerlink" title="二 基本功能的测试点分析"></a>二 基本功能的测试点分析</h2><p>对于本需求，可以按有效等价类划分法、无效等价类划分法、边界值分析法、错误推测法这4种方法来设计测试用例，以下给出附件上传的常见测试点。</p>
<h3 id="第一，有效等价类划分法的测试点有以下几个。"><a href="#第一，有效等价类划分法的测试点有以下几个。" class="headerlink" title="第一，有效等价类划分法的测试点有以下几个。"></a>第一，有效等价类划分法的测试点有以下几个。</h3><p>（1）分别单个上传所有格式的文件，且附件容量都是在1GB以内时，可上传成功。</p>
<p>（2）上传多个不同格式的附件（10个以内）并且附件总容量在5GB以内时，可上传成功。</p>
<p>（3）可以删除上传成功的文件。</p>
<p>（4）文件上传失败后，需给出正确合理的提示信息。</p>
<h3 id="第二，无效等价类划分法的测试点有以下几个。"><a href="#第二，无效等价类划分法的测试点有以下几个。" class="headerlink" title="第二，无效等价类划分法的测试点有以下几个。"></a>第二，无效等价类划分法的测试点有以下几个。</h3><p>上传需求文档规定以外的格式文件（如.html、.tif、.mp3、.avi、.iso等）时，均不可上传成功。</p>
<h3 id="第三，边界值分析法的测试点有以下几个。"><a href="#第三，边界值分析法的测试点有以下几个。" class="headerlink" title="第三，边界值分析法的测试点有以下几个。"></a>第三，边界值分析法的测试点有以下几个。</h3><p>（1）可以上传0KB的附件。</p>
<p>（2）可以上传一个1GB以内的附件。</p>
<p>（3）可以上传9个不同格式的5GB以内的附件。</p>
<p>（4）可以上传10个不同格式的5GB以内的附件。</p>
<p>（5）不可以上传11个不同格式的5GB以内的附件。</p>
<p>（6）可以上传一个0.99GB的附件</p>
<p>（7）可以上传一个1GB的附件。</p>
<p>（8）不可以上传一个1.01GB的附件</p>
<p>（9）可以上传多个不同格式的（10个以内）4.99GB的附件。</p>
<p>（10）可以上传多个不同格式的（10个以内）5GB的附件。</p>
<p>（11）不可以上传多个不同格式的（10个以内）5.01GB的附件。</p>
<p>备注：第一部分和第三部分测试点中如有重复的测试点需要在后期设计用例的时候进行合并。</p>
<h3 id="第四，错误推测法的测试点有以下几个。"><a href="#第四，错误推测法的测试点有以下几个。" class="headerlink" title="第四，错误推测法的测试点有以下几个。"></a>第四，错误推测法的测试点有以下几个。</h3><p>（1）不可以一次上传大批量文件（超过10个）。</p>
<p>（2）上传木马文件是否可检测（需要视需求而定）。</p>
<p>（3）上传可执行的文件（以.exe结尾的文件）是否可检测（需要视需求而定）。</p>
<p>（4）不可以上传超大容量文件（超过10GB）。</p>
<p>（5）如果存在已上传的同名文件，再次上传，检查文件能否正常上传（需要视需求而定）。</p>
<p>（6）是否可上传超长文件名的文件（需要视需求而定）。</p>
<p>（7）是否可上传一个正在打开的文件（需要视需求而定）。</p>
<p>（8）上传过程中网络中断后又恢复，是否可以接着之前的继续上传（需要视需求而定）。</p>
<p>（9）是否可以上传文件名包括特殊字符的文件（需要视需求而定）。</p>
<p>（10）是否可以上传文件名中包括中英混合字符的文件（需要视需求而定）。</p>
<p>（11）上传多个文件的过程中，一部分文件被删除或被重命名，是否会影响正在上传的文件（需要视需求而定）。</p>
<p>（12）上传文件的路径是否可手动进行输入（需要视需求而定）。</p>
<p>（13）检查文件上传的响应时间是否正常（是否符合需求规定）。</p>
<h3 id="第五，最后测试人员一样可以尝试一下随意性的无规则测试。"><a href="#第五，最后测试人员一样可以尝试一下随意性的无规则测试。" class="headerlink" title="第五，最后测试人员一样可以尝试一下随意性的无规则测试。"></a>第五，最后测试人员一样可以尝试一下随意性的无规则测试。</h3><p>这些测试点写出来之后，相信初学者都能看得懂，大体也知道如何利用以上的测试点去设计用例。对于第四部分中出现了几个视需求而定的测试点，这是因为在本例的需求文档中并没有对这些测试点给出明确的规格说明。在实际工作中，经常也会遇到需求文档对需求项的细节描述不是很详细的情况，很多隐含的需求在需求文档中并没有体现出来。在这种情况下，一方面要求测试人员在评审需求文档的时候更仔细一点，另一方面在设计测试用例或测试软件的过程当中要随时同产品经理或自己的领导沟通，找出这些隐含的需求标准，这样才能保证自己设计出来的用例覆盖面会更全面一些。初级软件测试人员由于相关的测试经验较少，如何去找这些隐含的需求呢？</p>
<p>建议初学者可以从以下方面入手。</p>
<p>（1）要紧扣需求文档，挖掘需求细节，并针对这些需求细节进行用例设计。</p>
<p>（2）除了应用所学习过的用例设计方法外，测试人员还应充分利用自己的发散能力和逻辑推理能力来设计，因为人的思维是开放的。</p>
<p>（3）想要更快地获取更多的测试思想，比较直接的办法就是通过互联网来获取相应的资料（因为常见功能点的测试网上几乎都有而且很全面），以此来充实自己的基础测试能力，并扩充视野。</p>
<p>（4）多与测试人员、开发人员、产品人员交流，多看测试人员之前写过的测试用例和相关文档。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-9</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-9/</url>
    <content><![CDATA[<h1 id="测试用例的评审"><a href="#测试用例的评审" class="headerlink" title="测试用例的评审"></a>测试用例的评审</h1><p>测试人员依据需求文档将测试用例设计完成后，如何确保设计的测试用例是正确无误的呢？这里有一个很重要的任务就是进行用例评审，通过对测试用例的评审以确保用例是<strong>全面的、正确的、没有冗余的。</strong></p>
<span id="more"></span>

<h1 id="如何评审测试用例"><a href="#如何评审测试用例" class="headerlink" title="如何评审测试用例"></a>如何评审测试用例</h1><p>测试用例的评审严格来讲是需要项目组的全体人员都参与的，但在实际工作中，一般都是只有本项目组的测试人员参与评审。评审测试用例前，测试人员会将自己编写的测试用例以文档的形式提前发送给测试组的全体成员，测试组的其他人员各自以文档批注的形式进行反馈或是由测试经理召开用例评审大会，以会议的形式进行评审。评审完成后，测试人员会依据其他测试人员的评审建议和意见进行修改。</p>
<p>一般情况下，测试人员会从以下几个方面对测试用例进行评审。</p>
<p>（1）测试用例是否是依据需求文档编写的。</p>
<p>（2）测试用例中的执行步骤、输入数据是否清晰、简洁、正确；对于重复度高的执行步骤，是否进行了简化。</p>
<p>（3）每个测试用例是否都有明确的预期结果。</p>
<p>（4）测试用例中是否存在多余的用例（无效、等价、冗余的用例）。</p>
<p>（5）测试用例是否覆盖了需求文档中所有的功能点，是否存在遗漏。</p>
<p>每个项目组评定测试用例的标准可能不尽相同，但最终的目的都是让<strong>测试用例变得简洁、全面，使测试人员执行用例时更具有针对性，更能发现问题。</strong></p>
<h1 id="用例设计结束的标准"><a href="#用例设计结束的标准" class="headerlink" title="用例设计结束的标准"></a>用例设计结束的标准</h1><p>当测试用例通过测试组的评审后，用例设计的工作是不是就结束了？答案是否定的，因为测试用例是依据需求文档编写的，在一定程度上限制了测试人员的想象力，但当测试人员接触了实际开发出来的软件时，便有了更多操作和想象的空间，那么在这个过程中会存在修改和增加用例的可能，另外在软件开发的过程中也可能会因某种原因新增或变更了一些需求细节，这个过程也存在修改用例的可能性。所以在产品上线前，测试人员需要一直维护测试用例。</p>
<h1 id="求职问题"><a href="#求职问题" class="headerlink" title="求职问题"></a>求职问题</h1><p>你是怎么设计测试用例的？</p>
<p>参考回答：我觉得设计一个功能模块的测试用例可以从如下方面：</p>
<p>首先最主要的要参考需求文档，尽可能多的挖掘需求点进行用例设计；</p>
<p>第二，根据常用的测试方法（等价类划分，边界值，正交表，）这些方法进行设计；</p>
<p>第三，用例模板可以参考以前同事写过的用例；</p>
<p>第四，也可以通过网络参考一些网上的资料进行设计；</p>
<p>基本上我会从这些方面进行用例的设计。</p>
<p>如何保证测试用例的质量（或者什么样测试用例才算好的用例？）</p>
<p>参考回答</p>
<ol>
<li><p>确保测试用例跟需求文档上面的需求点保持一致；</p>
</li>
<li><p>确保用例有足够多的异常场景（无效等价类的测试点），同时确保用例没有冗余；</p>
</li>
<li><p>用例要保证操作步骤，预期结果的准确性，简洁清晰，确保用例可操作性，可复用性(举例： 测试新系统的时候可以服用旧版本的用例)</p>
</li>
<li><p>测试用例的评审优化用例</p>
</li>
<li><p>用例要根据需求的变更及时更新</p>
</li>
</ol>
<p>没有需求文档，直接给你待测软件，你将如何开展测试工作？</p>
<p>参考答案：</p>
<ol>
<li><p>大致的运行一下软件，结合以往的经验，在有输入数据的地方使用边界值，等价类方式大致的测试一下。将测试出来的问题集中反馈给产品经理，待产品经理给出相应的标准后再设计用例。</p>
</li>
<li><p>在测试过程中，如果发现有些功能需求比较模糊，或者我觉得这个设计有问题（跟市场上其他同类应用设计有出入），对于这类问题，及时反馈给测试经理或者产品经理，确认这类问题。</p>
</li>
<li><p>积极参加各类与项目相关的会议，查看软件的使用手册，用户手册，查看已有的测试用例，Bug库中bug记录，尽可能多的了解需求。根据了解到需求设计测试用例。</p>
</li>
<li><p>将设计好的用例提交给测试组（必要的情况下提交给项目组）进行评审。以确保得到统一的意见。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Visual Studio 快捷键</title>
    <url>/%E7%AC%94%E8%AE%B0/vs-keys/</url>
    <content><![CDATA[<p>总结了几个Visual Studio 好用的快捷键，以后会再继续加。</p>
<span id="more"></span>



<table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>注释</td>
<td>Ctrl + K  Ctrl + C</td>
</tr>
<tr>
<td>取消注释</td>
<td>Ctrl + K  Ctrl + U</td>
</tr>
<tr>
<td>快速换行</td>
<td>Ctrl + Shift + Enter</td>
</tr>
<tr>
<td>复制当前行</td>
<td>Ctrl + D</td>
</tr>
<tr>
<td>强迫显示参数信息</td>
<td>Ctrl-Shift-空格</td>
</tr>
<tr>
<td>插入代码段</td>
<td>Ctrl+K，X</td>
</tr>
<tr>
<td>代码自动对齐</td>
<td>Ctrl+K+F</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>校园风景</title>
    <url>/%E7%9B%B8%E5%86%8C/xianlincampus/</url>
    <content><![CDATA[<h1 align = "center">校园风景自拍</h1>
​    

<h3 id="记录身边的美景😘"><a href="#记录身边的美景😘" class="headerlink" title="记录身边的美景😘"></a>记录身边的美景😘</h3><span id="more"></span>

<table>
      <tr> 
          <td align = "center"><img src="https://pic.imgdb.cn/item/60fe6aca5132923bf86f184e.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/60fe6a945132923bf86e57b3.jpg" style = "width:380px; height:214px" border=0></td> 
            <td align = "center"><img src="https://pic.imgdb.cn/item/60fe6cc95132923bf8769ed4.jpg" style = "width:380px; height:214px" border=0></td> 
      </tr>
</table>  


]]></content>
      <categories>
        <category>相册</category>
      </categories>
      <tags>
        <tag>校园</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试-6</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/software-testing-6/</url>
    <content><![CDATA[<h1 id="软件测试方法"><a href="#软件测试方法" class="headerlink" title="软件测试方法"></a>软件测试方法</h1><p>主要介绍软件测试的方法，包括白盒测试、灰盒测试、黑盒测试、静态测试、动态测试、手动测试、自动测试以及用例设计方法等。</p>
<h1 id="测试方法划分"><a href="#测试方法划分" class="headerlink" title="测试方法划分"></a>测试方法划分</h1><p>测试方法一般按以下几种划分：</p>
<ul>
<li><p>按照执行阶段划分为：白盒测试、黑盒测试、灰盒测试。</p>
</li>
<li><p>按照执行状态划分为：静态测试、动态测试。</p>
</li>
<li><p>按照执行行为划分为：手动测试、自动测试。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><p>白盒测试（White Box Testing）又称结构测试、逻辑驱动测试或基于代码的测试，主要检查产品内部结构是否按照规格说明书的规定正常运行。白盒测试是一种测试用例设计方法，盒子指的是被测试的软件，白盒顾名思义是指盒子是可视的，观察者清楚盒子内部的东西以及里面是如何运作的，因此，白盒测试需要测试人员对系统内部的结构和工作原理有一个清楚的了解。</p>
<h1 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h1><p>黑盒测试（Black Box Testing）也称功能测试，主要来检测每个功能是否都能正常使用。它也是在软件测试中使用最广泛的一类测试。</p>
<p>在黑盒测试中，通常把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，对程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601901151390-0f558b40-d3b6-4bbf-8ca6-8491514d1598.png" alt="img"></p>
<p>由于黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。所以黑盒测试是以用户的角度，从输入数据与输出数据的对应关系出发进行测试的。关注的是软件的功能需求，主要试图发现以下类型的错误：</p>
<ul>
<li><p>功能是否正确，是否有遗漏。</p>
</li>
<li><p>界面是否错误。</p>
</li>
<li><p>数据结构或外部数据库访问错误。</p>
</li>
<li><p>性能错误。</p>
</li>
</ul>
<p>在实际工作中，最常见的黑盒测试方法有：功能性测试、性能测试、安全性测试、兼容性测试、稳定性测试、可靠性测试以及安装卸载测试等。</p>
<p>从理论上讲，黑盒测试只有采用穷举输入测试，把所有可能的输入都作为测试情况进行考虑，才能查出程序中所有的错误。因为穷举测试是不可能的，所以要有针对性地选择测试用例。通过制定测试案例指导测试的实施，保证软件测试有组织、有计划地进行。只有对黑盒测试进行量化，才能保证软件的质量，具体量化的方法之一就是测试用例。</p>
<p>黑盒测试用例设计方法包括<strong>等****价类划分法、边界值分析法、判定表分析法、因果图分析法、正交试验法、流程分析法、状态迁移法、异常分析法以及错误推测法等</strong>。</p>
<h2 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h2><p>等价类划分法是一种典型的黑盒测试用例设计方法，使用等价类划分，是将软件的输入域分为若干部分，然后从每个部分中选取少数具有代表性的数据进行测试，这样可以避免穷举产生的大量用例。</p>
<p>等价类是指某个输入域的子集合，在该子集合中，每个输入数据对于揭露软件中的错误都是等效的。简单地说，就是指输入该输入域中的某一个数据，如不能揭露被测对象中的缺陷，那么我们就说这个输入域中的所有数据都无法揭露该缺陷，反之亦然。</p>
<p>等价类划分一般划分为两种情况：有效等价类和无效等价类。</p>
<ul>
<li><strong>有效等价类</strong>：对需求规格说明而言，合理的、有效的输入数据构成的集合。</li>
<li><strong>无效等价类</strong>：对需求规格说明而言，不合理的、无效的输入数据构成的集合。</li>
</ul>
<p>因为软件不仅要能接收合理的数据，不合理的数据也需要做出正确响应，所以在设计测试用例时，两种等价类都需要考虑，这样的测试才能确保软件具有更高的可靠性。</p>
<p>根据需求规格说明书确定被测对象的输入域，进行等价类划分。等价类划分的标准，划分的子集必须是互不相交的，符合完备测试，避免出现冗余。</p>
<p>等价类划分法的划分原则，通常按照以下规则进行划分等价类：</p>
<p>1）如果规定输入的取值范围或个数时，则划分一个有效等价类和两个无效等价类。如：注册用户名的长度限制6～18个字符，6～18个字符是有效等价类，小于6个字符和大于18个字符则是两个无效等价类。</p>
<p>2）如果规定了输入的集合或规则必须要遵循的条件，则划分一个有效等价类，和一个无效等价类。如：注册用户名的格式要求必须以字母开头时，以字母开头是有效等价类，非字母开头则是无效等价类。</p>
<p>3）如果输入条件是一个布尔值，则划分为一个有效等价类和一个无效等价类。如：在注册用户时需要遵循协议或条款是否接受时，“接受”是有效等价类，“不接受”则是无效等价类。</p>
<p>4）如果输入条件是一组数据（枚举值），并且程序对每一个输入的值做不同的处理，则化为若干个有效等价类和一个无效等价类。如：网游中充值VIP等级（3个等价），对每个VIP的等级优惠不同，VIP1、VIP2、VIP3不同等级是三个有效等价类，不是VIP用户则是无效等价类。</p>
<p>5）如果输入条件规定了必须要遵循的某些规则下，则划分为一个有效等价类和若干个无效等价类（无效等价类需要从不同的角度去违反规则）。如：密码要求首位必须是大写字母的，首字母大写是有效等价类，首位小写字母的、首位为数字的或首位为特殊字符的则是无效等价类。</p>
<p>6）不是所有的等价类都有无效等价类。如性别的选择只有男或女两种。</p>
<h3 id="【案例解析】"><a href="#【案例解析】" class="headerlink" title="【案例解析】"></a>【案例解析】</h3><p>某网站的用户注册的需求说明，用户名为必填项，要求长度为6～18个字符，并由字母、数字、下划线组成，必须以字母开头，结尾必须是数字或字母，而且不区分大小写字母，重名账号不允许注册。密码为必填项，要求8～15个字符，首位必须是大写字母，而且区分大小写字母。确认密码，要求与密码输入一致。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601901703384-f29d9620-6b8c-40e8-a450-37a10ba529f1.png" alt="img"></p>
<p>根据上面需求说明，首先进行划分等价类。经过细化后并将有效等价类和无效等价类填入等价类划分设计表中，并进行编号</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601902008514-459e4650-2615-4868-9065-426212943269.png" alt="img"></p>
<p>根据覆盖的规则，将测试数据覆盖的有效和无效等价类编号填入表中</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601902036904-54313a00-44dd-48c1-a6b3-ecbe157dbe02.png" alt="img"></p>
<p>最后根据上面的测试数据设计对应的测试用例</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601902075531-116778e1-e87f-4d28-b328-bd0683fb1151.png" alt="img"></p>
<h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><p>边界值分析法是对等价类划分法的一个补充，该方法不仅需要考虑输入域的边界，而且还要关注输出域的边界。由长期的测试工作经验得知，大量的错误发生在输入和输出范围的边界上。因此针对各种边界情况设计用例，可以查出更多的错误。</p>
<p>该方法一般在规定了取值范围或规定了值的个数，或者明确输入条件的有序集合中使用。</p>
<p>通常按照以下规则进行边界点的划分：</p>
<ul>
<li><p>如果规定了输入域的取值范围，则选取刚好在范围边界的点，以及刚好超过边界的点，作为测试的输入数据。</p>
</li>
<li><p>如果规定了输入值的个数，则用最大个数，最小个数，比最小个数少1，比最大个数多1的数作为测试数据。</p>
</li>
<li><p>如果规定了输入是一个有序的集合，则选取集合的第一个元素和最后一个元素作为测试数据。</p>
</li>
</ul>
<h3 id="【案例解析】-1"><a href="#【案例解析】-1" class="headerlink" title="【案例解析】"></a>【案例解析】</h3><p>某银行系统，允许用户通过日期对交易进行查询，系统对输入日期的限定为1990年1月～2049年12月，并规定：日期由6位数字字符组成，前4位表示年，后2位表示月。</p>
<p>分析输入条件有6位数字字符，年份的范围，月份范围，</p>
<table>
<thead>
<tr>
<th>输入条件</th>
<th>有效等价类</th>
<th>有效边界点</th>
<th>无效等价类</th>
<th>无效边界点</th>
</tr>
</thead>
<tbody><tr>
<td>日期长度</td>
<td>6位数字字符</td>
<td>6位</td>
<td>小于6位数字字符</td>
<td>5位</td>
</tr>
<tr>
<td>大于6位数字字符</td>
<td>7位</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>日期类型</td>
<td>数字字符</td>
<td>无</td>
<td>非数字字符</td>
<td>无</td>
</tr>
<tr>
<td>年份范围</td>
<td>1990-2049</td>
<td>1990,2049 1991,2048</td>
<td>小于1990</td>
<td>1989</td>
</tr>
<tr>
<td>大于2049</td>
<td>2050</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>月份范围</td>
<td>01-12</td>
<td>01,12 02,11</td>
<td>小于1</td>
<td>00</td>
</tr>
<tr>
<td>大于12</td>
<td>13</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="判定表分析法"><a href="#判定表分析法" class="headerlink" title="判定表分析法"></a>判定表分析法</h2><p>在等价类设计法中，没有考虑输入域的组合情况，导致设计的用例中无法覆盖输入域之间存在关联的地方。为了弥补等价类设计的不足，这里介绍一种新的用例设计方法——判定表分析法。</p>
<p>判定表分析法主要是分析和表达多种输入条件下系统执行不同动作的技术。在程序设计发展的初期，判定表就已被当作编写程序的辅助工具了，它可以把复杂的逻辑关系和多种条件组合的情况表达得很明确。判定表由四个部分组成，</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601902548319-855aff0c-1b5e-4350-9ea3-3f2c664a6eff.png" alt="img"></p>
<p>1）条件桩：列出被测对象的所有输入，并列出输入条件与次序无关。</p>
<p>2）动作桩：列出输入条件系统可能采取的操作，这些操作的排序顺序没有约束。</p>
<p>3）条件项：列出输入条件的其他取值，在所有可能情况下的真假值。</p>
<p>4）动作项：列出在条件项的各种取值情况下应采取的动作。</p>
<h3 id="【案例解析】-2"><a href="#【案例解析】-2" class="headerlink" title="【案例解析】"></a>【案例解析】</h3><p>书籍阅读指南，需求描述如下：</p>
<p>1）觉得疲倦但对书的内容感兴趣，同时书的内容让你糊涂，回到本章重读。</p>
<p>2）觉得疲倦但对书的内容感兴趣，同时书的内容不让你糊涂，继续读下去。</p>
<p>3）不觉得疲倦并对书的内容感兴趣，同时书的内容让你糊涂的话，回到本章重读。</p>
<p>4）觉得疲倦并对书的内容不感兴趣，同时书的内容不让你糊涂，停止阅读休息。</p>
<p>5）觉得疲倦并对书的内容不感兴趣，并且书的内容让你糊涂，请停止阅读休息。</p>
<p>6）不疲倦，对书的内容感兴趣，书的内容不糊涂，继续读下去。</p>
<p>7）不疲倦，不感兴趣，对书的内容糊涂，跳到下一章去读。</p>
<p>8）不疲倦，不感兴趣，对书的内容不糊涂，跳到下一章去读。</p>
<p>首先分析条件桩和动作桩，条件项有您觉得疲倦吗、您对书中的内容感兴趣吗、书的内容让你糊涂吗；动作桩有回到本章重读、继续读下去、跳到下一章去读、请停止阅读休息。</p>
<p>其次根据条件来计算规则23个（即8），构成判定表.</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601902972776-93d32d61-040d-41bc-9c9d-7b2992df9b9a.png" alt="img"></p>
<p>再根据合并规则，将1和5、2和6、3和4、7和8合并得到判定表</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601902988473-ad1004b6-c5cd-4a0e-8d33-68918e2fe98c.png" alt="img"></p>
<p>合并后只剩4条规则，看上去用例数减少了，但是很容易产生漏测的风险。</p>
<h2 id="因果图分析法"><a href="#因果图分析法" class="headerlink" title="因果图分析法"></a>因果图分析法</h2><p>在利用判定表设计用例的过程中，如果条件过多，导致设计判定表比较困难。为了弥补该缺点，接下来介绍一种新的测试用例设计方法——因果图分析法。</p>
<p>因果图分析法是分析输入条件之间的约束情况，然后生成判定表，进行用例设计。下面介绍一下因果图的基本图形符号：因果符号和约束符号。</p>
<h3 id="因果符号"><a href="#因果符号" class="headerlink" title="因果符号"></a>因果符号</h3><p>因果是指输入和输出的因果关系。因果符号有<strong>恒等、非、或、与</strong>四种表示方法，如图所示，其中c1表示输入的状态，即原因、e1表示输出的状态，即结果。c1和e1均可取值0或1（0表示某状态不出现，1表示某状态出现）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601903308725-fa197435-6e4e-43e4-9cf4-0010a67bf696.png" alt="img"></p>
<ul>
<li><p><strong>恒等</strong>：当输入条件发生时，则一定会产生对应的输出；相反当输入条件不发生时，则不产生对应的输出。即c1为1时，e1一定为1；否则c1为0，e1一定为0；</p>
</li>
<li><p><strong>非</strong>：与恒等相反，当输入条件发生时，则不产生对应的输出；反之亦然。即c1为1时，e1一定为0；否则c1为0，e1一定为1；</p>
</li>
<li><p><strong>或</strong>：当输入多个条件时，只要有其中一个条件发生，则产生对应的输出。即只要c1、c2、c3其中一个为1，则e1为1；只有c1、c2、c3全部为0时，e1才为0；</p>
</li>
<li><p><strong>与</strong>：当输入多个条件时，只有所有的输入条件发生时，才会产生对应的输出。即c1、c2都为1时，e1才为1；只要c1、c2其中一个为0，e1为0。</p>
</li>
</ul>
<h3 id="约束符号"><a href="#约束符号" class="headerlink" title="约束符号"></a>约束符号</h3><p>约束是指输入与输入之间存在的某些依赖关系，称为约束。约束符号有<strong>异、或、唯一、要求、强制</strong>五种表示方法，其中前面四种是针对输入条件的约束，最后一种强制只针对输出条件的约束。</p>
<p>其中a，b分别代表条件。条件的取值0或1（0表示某状态不出现，1表示某状态出现）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601903437579-4ee38fa4-b813-448a-98ec-46f77071a330.png" alt="img"></p>
<ul>
<li><p><strong>异</strong>：在所有输入条件中，至多有一个可能不发生。即图4-11中，a和b最多只有一个为1，不能同时为1，但可以同时为0。</p>
</li>
<li><p><strong>或</strong>：在所有输入条件中，至少有一个发生。即图4-11中，a、b、c最少有一个为1，不能同时为0，但可以同时为1。</p>
</li>
<li><p><strong>唯一</strong>：在所有输入条件中，有且只有一个发生。即图4-11中，a和b，只有一个为1，不能同时为1，也不能同时为0。</p>
</li>
<li><p><strong>要求</strong>：在所有输入条件中，只要有一个发生，则要求其他条件也发生。即图4-11中，a和b，a为1时，要求b也为1。</p>
</li>
<li><p><strong>强制</strong>：是针对结果的约束关系，当一个结果发生，强制另一个结果不发生。</p>
</li>
</ul>
<h3 id="【案例解析】-3"><a href="#【案例解析】-3" class="headerlink" title="【案例解析】"></a>【案例解析】</h3><p>需求规定：当输入的第一列字符必须是X或Y，第二列字符必须是一个数字时，对文件进行修改，如果第一列字符不正确，则给出信息A；如果第二列字符不正确，则给出信息B。</p>
<p>首先分析原因和结果，并进行编号</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601903584378-3f22679c-c051-4c97-8088-fa8212324195.png" alt="img"></p>
<p>再根据它们之间的对应关系，画出因果图并标记约束符号</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601903614195-18e62304-e034-4eed-af88-425136c5d769.png" alt="img"></p>
<p>再根据因果图转换为判定表（Y代表出现、N代表不出现）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601903635420-647c78b4-7f35-493d-b89f-744e6441568f.png" alt="img"></p>
<p>由于原因1和2不可能同时出现，故规则1、2属于不可能发生的组合，即1、2规则的测试用例可以不考虑。最终生成的测试用例就是规则3、4、5、6、7、8共计六条。</p>
<h2 id="正交试验法"><a href="#正交试验法" class="headerlink" title="正交试验法"></a>正交试验法</h2><p>正交试验法是从大量的试验点中挑选出适量的、有代表性的点，应用依据迦罗瓦理论导出的“正交表”，合理的安排试验的一种科学的试验设计方法。它是根据正交性从全面试验中挑选出部分有代表性的点进行试验，这些有代表性的点具备了“均匀分散，齐整可比”的特点，是研究多因素多层次采样点的一种设计方法，正交试验设计是一种基于正交表的、高效率、快速、经济的试验设计方法。</p>
<p>正交试验中常用的术语有指标、因子、因子状态三个。</p>
<ul>
<li><p><strong>指标</strong>：通常把判断试验结果优劣的标准叫做试验的指标。</p>
</li>
<li><p><strong>因子</strong>：把所有影响试验指标的条件称为因子。</p>
</li>
<li><p><strong>因子的状态</strong>：把影响试验因子称为因子的状态。</p>
</li>
</ul>
<p>正交试验表示形式有2种：Lr（mn）或Lr（mn，pq），其中n、q代表因子数，即正交表中的列；m、p代表水平数也称状态，即单个因子取的最大数；r代表行数，正交表中行的数量，即测试用例数。简单地说正交试验法就是测试组合的方法，这一点跟判定表法类似，但是判定表法是通过人工对全排列组合来进行化简得到测试用例，而正交试验法是借助数学工具，通过算法从全排列组合中选择组合并放到正交表中，通过查看合适的正交表，可以直接得到测试用例。正交表的原理就是两两组合。</p>
<h3 id="【案例解析】-4"><a href="#【案例解析】-4" class="headerlink" title="【案例解析】"></a>【案例解析】</h3><p>某数据库查询系统，规定查询条件，可以按照功能、结构、逻辑符号等查询类别进行查询；也可按照简单、组合、条件等查询方式进行查询；还可以按照元门、功能块等元胞类别进行查询；还可以按照终端显示、图形显示、行式打印等打印方式进行查询。</p>
<p>根据规定分析因子和因子的状态，可得到因子——状态表</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601904522378-abcdfb10-6560-4141-a719-f9ef4c52de23.png" alt="img"></p>
<p>根据规格分析，在上表中，因为打印方式的权值和查询类别中逻辑符号的权值比较小，所以我们将这些权值比较小的因子或状态进行加权筛选，得到分析表，</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601904545491-7d01f13d-42d1-42f6-bd45-85e91855c0ff.png" alt="img"></p>
<p>再将上面的查询方式中简单和组合进行合并，得到组合后的因素表</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601904560525-81e43fae-6137-44a1-8cb4-0fcae010ca56.png" alt="img"></p>
<p>再将合并后的因素表，替换到正交表3因子2状态中</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601904583819-2e3adc9e-b362-44e3-8bd8-ffd9962019a1.png" alt="img"></p>
<p>进行分解，最后得到具有6条测试用例的测试数据集</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601904616911-d0f1262d-2045-48ea-a9b7-3037b0e586e8.png" alt="img"></p>
<p>根据表途中中每行的测试数据生成测试用例。需要注意的是，在最后设计用例时，需要补充已筛选权值比较小的测试用例，即查询类别为逻辑符号的测试用例。</p>
<p>因为在正交表中有4因子3状态，所以该案例还可以采用直接补空状态进行设计用例。然后再用其他状态替换补空的状态（即空状态可以用门或功能块替换）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601904728119-ca564d76-e90b-43f8-9378-171ff19809e8.png" alt="img"></p>
<p>虽然该方法在工作中使用比较广泛，但需要注意正交表中包含的组合并没有考虑实际取值的意义，因此可能出现无效的组合。在设计中需要删除无效组合，还需要补充遗漏的常见组合。</p>
<h2 id="流程分析法"><a href="#流程分析法" class="headerlink" title="流程分析法"></a>流程分析法</h2><p>流程分析法也称场景法，主要是针对测试场景类型。它是从白盒测试设计方法中的路径覆盖分析法演变过来的一种重要的方法。在白盒测试中，路径就是指函数代码的某个分支组合，路径覆盖法需要构造足够的用例覆盖函数的所有代码路径。在黑盒测试中，若将软件系统的某个流程看成路径的话，则可以针对该路径使用路径分析的方法设计测试用例。</p>
<p>在实际工作中，流程分析法是最容易理解和执行的，它是主要通过流程对系统的功能点或业务流程进行描述，可以展示测试效果。流程分析法一般包含基本流和备选流，从一个流程开始，通过描述经过的路径来遍历所有的基本流和备选流。</p>
<ul>
<li>基本流：是指程序的主流程，是实现业务流程最简单的路径。</li>
<li>备选流：是指实现业务流程时，因错误操作或者是异常操作，导致最终未达到目的流程。</li>
</ul>
<p>直线表示基本流；其他曲线表示为备选流。由图可以看到，一个备选流可以从基本流开始；也可以从备选流开始。备选流的终点，可以是一个流程的出口，也可以是回到基本流，还可以是汇入其他的备选流。可以确认的流程如下所示：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601904816758-71340bec-3cea-4f15-851f-372f9ba607a6.png" alt="img"></p>
<p>流程1：基本流</p>
<p>流程2：基本流→备选流1</p>
<p>流程3：基本流→备选流1→备选流2</p>
<p>流程4：基本流→备选流3</p>
<p>流程5：基本流→备选流3→备选流1</p>
<p>流程6：基本流→备选流3→备选流1→备选流2</p>
<p>流程7：基本流→备选流4</p>
<p>流程8：基本流→备选流3→备选流4</p>
<h3 id="【案例解析】-5"><a href="#【案例解析】-5" class="headerlink" title="【案例解析】"></a>【案例解析】</h3><p>某银行ATM取款机的取款流程进行测试。首先画取款的流程图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/87080/1601904931891-5f500bd8-5f50-413a-adac-d5fc0a34575d.jpeg" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/87080/1601904974673-79b4a2f7-4852-4342-9140-cc8db38a767c.jpeg" alt="img"></p>
<p>其次生成ATM取款的流程</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/87080/1601905015512-b4583280-87b7-4104-b8ec-090bc03995b4.jpeg" alt="img"> </p>
<h2 id="状态迁移法"><a href="#状态迁移法" class="headerlink" title="状态迁移法"></a>状态迁移法</h2><p>状态迁移法是通过把被测系统，分析出它的若干个状态，以及这些状态之间的转换条件和路径，那么就可以从状态迁移路径覆盖的角度来对设计用例进行测试。其主要验证在给定的条件内是否能够产生需要的状态变化，是否存在不可能达到的状态或非法的状态，是否可能产生非法的状态转移等。在黑盒测试中主要目标是设计足够的用例达到对系统状态的覆盖、状态-条件组合的覆盖以及状态迁移路径的覆盖。</p>
<p>简单来说，状态迁移就是将程序的业务流程中每个节点用状态来描述，通过触发的事件来完成各状态之间的转换。</p>
<p>实际工作中，在业务流程中都涉及了复杂的业务场景（即业务状态的迁移）。而这些业务场景在需求规格中往往不能够完全阐述清楚，容易出现遗漏。所以当被测系统的业务场景复杂时，在工程中应用这种针对状态迁移测试的思路完成对复杂业务场景的测试有时是很有必要的。</p>
<h3 id="【案例解析】-6"><a href="#【案例解析】-6" class="headerlink" title="【案例解析】"></a>【案例解析】</h3><p>Bug测试流程：测试人员提交新问题单，项目测试经理（TPM）审核问题单，如果不是问题，则作为非问题关闭，如果重复则作为重复问题关闭，否则置为打开状态。开发人员分析打开状态的问题单，如果接受则进行修改。否则应与测试人员协商，在问题单提交人同意的情况下，可退回给测试人员作为非问题关闭。对于开发人员拒绝修改，但测试人员无法认同的情况，该问题单需提交CCB评审，根据评审结果，如果确认要修改则进入修改状态，如果不是问题则作为非问题关闭，如果是问题但暂时无法解决则挂起，挂起的问题单到达指定修改期限时，会再次进入打开状态。修改后的问题单需由测试人员进行回归测试，如果回归通过则关闭问题单，如果回归不通过则重新进入打开状态。</p>
<p>首先根据描述确定流程的节点，即节点状态，分析状态之间的迁移关系，用圆圈代表状态，箭头代表状态迁移方向，绘制状态迁移图</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601905856393-d6acc8a3-8762-4544-9f80-0d322f540b1f.png" alt="img"></p>
<p>其次根据状态图，将输入不同条件导致的输出和状态迁移列入表中</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/87080/1601905873139-0d1fcf2a-baf3-471f-a73e-d1f3db80e059.png" alt="img"></p>
<p>最后可以根据状态事件表设计测试路径，最后生成测试用例，还要设计非法状态转换的测试用例。</p>
<h2 id="异常分析法"><a href="#异常分析法" class="headerlink" title="异常分析法"></a>异常分析法</h2><p>异常分析就是针对系统有可能存在的异常操作、软硬件缺陷引起的故障进行分析，依此设计测试用例。一方面主要针对系统的容错能力、故障恢复能力进行测试。另一方面，针对系统资源的异常进行测试。简单地说，就是通过人为的制造异常情况，来检查系统处理能力。</p>
<p>下面主要介绍一下常见的异常分析情况：</p>
<p>1）测试软件不按照正常的流程运行。</p>
<p>2）删除或修改系统的重要配置文件。</p>
<p>3）比如特殊符号“/”斜杠、“./”点斜杠、“‘”单引号以及空格等。</p>
<p>4）强行关闭数据库服务器、制造数据库死机、非法破坏数据表或数据等。</p>
<p>5）增加服务器资源的使用情况，CPU、内存、硬盘等。</p>
<p>6）对部分或者所有相关软件进行断电测试。</p>
<h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>在软件测试中，基于经验和直觉推测程序中可能存在的各种错误，从而有针对性的设计测试用例的方法，就是错误推测法。</p>
<p>它的基本的设计思路就是分析程序中最易出错的场景和情况，在此基础上有针对性的设计测试用例。</p>
<p>需要测试人员深度熟悉被测系统的业务、需求，对被测系统或类似系统之前的缺陷分布情况进行过系统的分析，包括功能缺陷、数据缺陷、接口缺陷和界面缺陷等。在实际测试活动中，随着对产品的了解的加深和测试经验的丰富，使得错误推测法设计的测试用例往往非常有效，可以作为测试设计的一种补充手段。简单说就是积累的经验越丰富，方法使用效率越高。错误推测不是瞎猜，主要是针对系统可能存在的薄弱环节的测试补充，而不是为了覆盖而测试。</p>
<h2 id="黑盒测试的优缺点"><a href="#黑盒测试的优缺点" class="headerlink" title="黑盒测试的优缺点"></a>黑盒测试的优缺点</h2><p>黑盒测试使用范围比较广泛，其优点主要是站在用户的角度进行测试，测试人员不需要了解程序实现的细节，相对白盒测试而言，黑盒测试的测试数据很容易生成，但是要测试到每一个输入流几乎是不可能的，其最大的缺点就是不能针对特定的程序段，这样很容易造成程序路径的漏测，当程序非常复杂时其隐藏的问题很难发现。在实际工作中，由于黑盒测试的测试人员编程能力相对薄弱，所以大部分测试人员现在研究的都是介于白盒和黑盒之间，就是灰盒测试，也是常说的接口测试。</p>
]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB命令详解及用法大全</title>
    <url>/%E7%AC%94%E8%AE%B0/adb-keys/</url>
    <content><![CDATA[<h2 id="一、ADB是什么？"><a href="#一、ADB是什么？" class="headerlink" title="一、ADB是什么？"></a>一、ADB是什么？</h2><p>ADB，即 <a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a> 是一种允许模拟器或已连接的 Android 设备进行通信的命令行工具，它可为各种设备操作提供便利，如安装和调试应用，并提供对 <code>Unix shell</code>（可用来在模拟器或连接的设备上运行各种命令）的访问。可以在<code>Android SDK/platform-tools</code>中找到 <code>adb</code> 工具。</p>
<p><strong>注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</strong></p>
<span id="more"></span>

<h2 id="二、ADB有什么作用？"><a href="#二、ADB有什么作用？" class="headerlink" title="二、ADB有什么作用？"></a>二、ADB有什么作用？</h2><p><code>ADB</code> 是 <code>Android SDK</code> 里的一个工具, 用这个工具可以直接操作管理Android模拟器或者真实的Android设备。它的主要功能有:</p>
<ul>
<li><p>在设备上运行Shell命令；</p>
</li>
<li><p>将本地APK软件安装至模拟器或Android设备；</p>
</li>
<li><p>管理设备或手机模拟器上的预定端口；</p>
</li>
<li><p>在设备或手机模拟器上复制或粘贴文件。</p>
</li>
</ul>
<p><code>ADB</code> 是一个<code>客户端-服务器程序</code>程序，包括三个组件：</p>
<ul>
<li><p><strong>客户端</strong>：该组件发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端。</p>
</li>
<li><p><strong>后台程序</strong>：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行。</p>
</li>
<li><p><strong>服务器</strong>：该组件管理客户端和后台程序之间的通信。服务器在开发计算机上作为后台进程运行。</p>
</li>
</ul>
<h2 id="三、ADB命令语法"><a href="#三、ADB命令语法" class="headerlink" title="三、ADB命令语法"></a>三、ADB命令语法</h2><p>adb 命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serial-number&gt;] &lt;command&gt;</span><br></pre></td></tr></table></figure>

<h3 id="单一设备-模拟器连接"><a href="#单一设备-模拟器连接" class="headerlink" title="单一设备/模拟器连接"></a>单一设备/模拟器连接</h3><p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s ]</code> 这一部分，直接使用 <code>adb </code>。</p>
<h3 id="多个设备-模拟器连接"><a href="#多个设备-模拟器连接" class="headerlink" title="多个设备/模拟器连接"></a>多个设备/模拟器连接</h3><p>如果有多个设备/模拟器连接，则需要为命令指定目标设备，下表是指定目标设备的命令选项：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s </code></td>
<td>指定相应设备序列号的设备/模拟器为命令目标</td>
</tr>
</tbody></table>
<p>在多个设备/模拟器连接的情况下较常用的是 <code>-s </code> 参数，<code>serial-number</code>是指设备的设备序列号，可以通过 <code>adb devices</code> 命令获取。</p>
<h2 id="四、ADB常用命令"><a href="#四、ADB常用命令" class="headerlink" title="四、ADB常用命令"></a>四、ADB常用命令</h2><h3 id="4-1-基本命令"><a href="#4-1-基本命令" class="headerlink" title="4.1 基本命令"></a>4.1 基本命令</h3><h4 id="4-1-1-查看adb的版本信息"><a href="#4-1-1-查看adb的版本信息" class="headerlink" title="4.1.1 查看adb的版本信息"></a>4.1.1 查看adb的版本信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-启动adb"><a href="#4-1-2-启动adb" class="headerlink" title="4.1.2 启动adb"></a>4.1.2 启动adb</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure>

<p>一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。</p>
<h4 id="4-1-3-停止adb"><a href="#4-1-3-停止adb" class="headerlink" title="4.1.3 停止adb"></a>4.1.3 停止adb</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure>

<h4 id="4-1-4-以-root-权限运行-adb"><a href="#4-1-4-以-root-权限运行-adb" class="headerlink" title="4.1.4 以 root 权限运行 adb"></a>4.1.4 以 root 权限运行 adb</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br></pre></td></tr></table></figure>

<h4 id="4-1-5-指定-adb-server-的网络端口"><a href="#4-1-5-指定-adb-server-的网络端口" class="headerlink" title="4.1.5 指定 adb server 的网络端口"></a>4.1.5 指定 adb server 的网络端口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb -P &lt;port&gt; start-server</span><br></pre></td></tr></table></figure>

<p>ADB的默认端口为 5037。</p>
<h4 id="4-1-5-查询已连接的设备-模拟器列表"><a href="#4-1-5-查询已连接的设备-模拟器列表" class="headerlink" title="4.1.5 查询已连接的设备/模拟器列表"></a>4.1.5 查询已连接的设备/模拟器列表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<h3 id="4-2-设备连接管理"><a href="#4-2-设备连接管理" class="headerlink" title="4.2 设备连接管理"></a>4.2 设备连接管理</h3><h4 id="4-2-1-USB-连接"><a href="#4-2-1-USB-连接" class="headerlink" title="4.2.1 USB 连接"></a>4.2.1 USB 连接</h4><p>通过 USB 连接来正常使用 adb 需要以下步骤：</p>
<ol>
<li><p>确认硬件状态正常(包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好)。</p>
</li>
<li><p>Android 设备的开发者选项和 USB 调试模式已开启(可以在「设置」-「开发者选项」-「USB调试」打开USB调试)。</p>
</li>
<li><p>确认设备驱动状态正常(安装ADB驱动程序)。</p>
</li>
<li><p>通过 USB 线连接好电脑和设备后确认状态。</p>
</li>
<li><p>通过 <code>adb devices</code> 命令查看设备连接情况。</p>
</li>
</ol>
<h4 id="4-2-2-WLAN-连接（需要-USB-线）"><a href="#4-2-2-WLAN-连接（需要-USB-线）" class="headerlink" title="4.2.2 WLAN 连接（需要 USB 线）"></a>4.2.2 WLAN 连接（需要 USB 线）</h4><p>借助 USB 通过 WiFi 连接来正常使用 adb 需要以下步骤： 操作步骤：</p>
<ol>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个 WiFi。</p>
</li>
<li><p>将设备与电脑通过 USB 线连接(可通过 <code>adb devices</code> 命令查看设备连接情况)。</p>
</li>
<li><p>通过 <code>adb tcpip 5555</code> 命令让设备在 5555 端口监听 TCP/IP 连接。</p>
</li>
<li><p>断开 USB 连接。</p>
</li>
<li><p>找到设备的 IP 地址(可以在「设置」-「关于手机」-「状态信息」-「IP地址」查看 IP 地址)。</p>
</li>
<li><p>通过 <code>adb connect </code> 命令使用 IP 地址将 Android 设备与电脑连接。</p>
</li>
<li><p>通过 <code>adb devices</code> 命令查看设备连接情况。</p>
</li>
<li><p>使用完毕后可通过 <code>adb disconnect </code> 命令断开无线连接。</p>
</li>
</ol>
<h4 id="4-2-3-WLAN-连接（无需借助-USB-线）"><a href="#4-2-3-WLAN-连接（无需借助-USB-线）" class="headerlink" title="4.2.3 WLAN 连接（无需借助 USB 线）"></a>4.2.3 WLAN 连接（无需借助 USB 线）</h4><p><strong>注：需要 root 权限。</strong> 不借助 USB 通过 WiFi 连接来正常使用 adb 需要以下步骤：</p>
<ol>
<li><p>在 Android 设备上安装一个终端模拟器(可通过<a href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a>下载)。</p>
</li>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个 WiFi。</p>
</li>
<li><p>打开 Android 设备上的终端模拟器，在里面依次运行命令：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port 5555</span><br></pre></td></tr></table></figure>

<ol>
<li><p>找到设备的 IP 地址(可以在「设置」-「关于手机」-「状态信息」-「IP地址」查看 IP 地址)。</p>
</li>
<li><p>通过 <code>adb connect </code> 命令使用 IP 地址将 Android 设备与电脑连接。</p>
</li>
<li><p>通过 <code>adb devices</code> 命令查看设备连接情况。</p>
</li>
</ol>
<h4 id="4-2-4-WiFi-连接转为-USB-连接"><a href="#4-2-4-WiFi-连接转为-USB-连接" class="headerlink" title="4.2.4 WiFi 连接转为 USB 连接"></a>4.2.4 WiFi 连接转为 USB 连接</h4><p>通过<code>adb usb</code>命令以USB模式重新启动ADB：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb usb</span><br></pre></td></tr></table></figure>

<h3 id="4-3-应用管理"><a href="#4-3-应用管理" class="headerlink" title="4.3 应用管理"></a>4.3 应用管理</h3><h4 id="4-3-1-查看应用列表"><a href="#4-3-1-查看应用列表" class="headerlink" title="4.3.1 查看应用列表"></a>4.3.1 查看应用列表</h4><p>查看应用列表的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>adb shell pm list packages</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td>``</td>
<td>包名包含 `` 字符串</td>
</tr>
</tbody></table>
<h5 id="4-3-1-1-查看所有应用"><a href="#4-3-1-1-查看所有应用" class="headerlink" title="4.3.1.1 查看所有应用"></a>4.3.1.1 查看所有应用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-2-查看系统应用"><a href="#4-3-1-2-查看系统应用" class="headerlink" title="4.3.1.2 查看系统应用"></a>4.3.1.2 查看系统应用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-3-查看第三方应用"><a href="#4-3-1-3-查看第三方应用" class="headerlink" title="4.3.1.3 查看第三方应用"></a>4.3.1.3 查看第三方应用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-4-包名包含某字符串的应用"><a href="#4-3-1-4-包名包含某字符串的应用" class="headerlink" title="4.3.1.4 包名包含某字符串的应用"></a>4.3.1.4 包名包含某字符串的应用</h5><p>比如要查看包名包含字符串 <code>huawei</code> 的应用列表，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages huawei</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-安装应用"><a href="#4-3-2-安装应用" class="headerlink" title="4.3.2 安装应用"></a>4.3.2 安装应用</h4><p>安装应用的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb install [-l] [-r] [-t] [-s] [-d] [-g] &lt;apk-file&gt;</span><br></pre></td></tr></table></figure>

<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody></table>
<p>运行命令后可以看到输出内容，包含安装进度和状态，安装状态如下：</p>
<ul>
<li><code>Success</code>：代表安装成功。</li>
<li><code>Failure</code>：代表安装失败。 APK 安装失败的情况有很多，<code>Failure</code>状态之后有安装失败输出代码。常见安装失败输出代码、含义及可能的解决办法如下：</li>
</ul>
<table>
<thead>
<tr>
<th>输出代码</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall </code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall </code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败; 2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储; 2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置; 2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数; 2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td>
<td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody></table>
<p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java">PackageManager.java</a></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li><p>push apk 文件到 /data/local/tmp。</p>
</li>
<li><p>调用 pm install 安装。</p>
</li>
<li><p>删除 /data/local/tmp 下的对应 apk 文件。</p>
</li>
</ol>
<h4 id="4-3-3-卸载应用"><a href="#4-3-3-卸载应用" class="headerlink" title="4.3.3 卸载应用"></a>4.3.3 卸载应用</h4><p>卸载应用的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb uninstall [-k] &lt;package-name&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>`` 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<h4 id="4-3-4-清除应用数据与缓存"><a href="#4-3-4-清除应用数据与缓存" class="headerlink" title="4.3.4 清除应用数据与缓存"></a>4.3.4 清除应用数据与缓存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm clear &lt;package-name&gt;</span><br></pre></td></tr></table></figure>

<p>`` 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<h4 id="4-3-5-查看前台-Activity"><a href="#4-3-5-查看前台-Activity" class="headerlink" title="4.3.5 查看前台 Activity"></a>4.3.5 查看前台 Activity</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mFocusedActivity</span><br></pre></td></tr></table></figure>

<h4 id="4-3-6-查看正在运行的-Services"><a href="#4-3-6-查看正在运行的-Services" class="headerlink" title="4.3.6 查看正在运行的 Services"></a>4.3.6 查看正在运行的 Services</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;package-name&gt;]</span><br></pre></td></tr></table></figure>

<p><code>参数不是必须的，指定</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。`` 不一定要给出完整的包名，可以只给一部分，那么所给包名相关的 Services 都会列出来。</p>
<h4 id="4-3-7-查看应用详细信息"><a href="#4-3-7-查看应用详细信息" class="headerlink" title="4.3.7 查看应用详细信息"></a>4.3.7 查看应用详细信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys package &lt;package-name&gt;</span><br></pre></td></tr></table></figure>

<p>`` 表示应用包名。运行次命令的输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<h4 id="4-3-7-查看应用安装路径"><a href="#4-3-7-查看应用安装路径" class="headerlink" title="4.3.7 查看应用安装路径"></a>4.3.7 查看应用安装路径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm path &lt;package-name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-与应用交互"><a href="#4-4-与应用交互" class="headerlink" title="4.4 与应用交互"></a>4.4 与应用交互</h3><p>与应用交互主要是使用 <code>am </code> 命令，常用的 `` 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>start [options] </code></td>
<td>启动 `` 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] </code></td>
<td>启动 `` 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] </code></td>
<td>发送 `` 指定的广播</td>
</tr>
<tr>
<td><code>force-stop </code></td>
<td>停止 `` 相关的进程</td>
</tr>
</tbody></table>
<p>`` 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-a </code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c </code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n </code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity</td>
</tr>
</tbody></table>
<p>`` 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>--esn </code></td>
<td>null 值(只有 key 名)</td>
</tr>
<tr>
<td>`-e</td>
<td>–es  `</td>
</tr>
<tr>
<td><code>--ez  </code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei  </code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el  </code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef  </code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu  </code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn  </code></td>
<td>component name</td>
</tr>
<tr>
<td>`–eia  [,</td>
<td>integer 数组</td>
</tr>
<tr>
<td>`–ela  [,</td>
<td>long 数组</td>
</tr>
</tbody></table>
<h4 id="4-4-1-启动应用-调起-Activity"><a href="#4-4-1-启动应用-调起-Activity" class="headerlink" title="4.4.1 启动应用/ 调起 Activity"></a>4.4.1 启动应用/ 调起 Activity</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start [options] &lt;intent&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am start -a android.settings.SETTINGS                   # 打开系统设置页面</span><br><span class="line">adb shell am start -a android.intent.action.DIAL -d tel:10086     # 打开拨号页面</span><br><span class="line">adb shell am start -n com.android.mms/.ui.ConversationList        # 打开短信会话列表</span><br></pre></td></tr></table></figure>

<p>options 是一些改变其行为的选项，支持的可选参数及含义如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-D</td>
<td>启用调试</td>
</tr>
<tr>
<td>-W</td>
<td>等待启动完成</td>
</tr>
<tr>
<td>–start-profiler <code>file</code></td>
<td>启动分析器并将结果发送到 <code>file</code></td>
</tr>
<tr>
<td>-P <code>file</code></td>
<td>类似于 –start-profiler，但当应用进入空闲状态时分析停止</td>
</tr>
<tr>
<td>-R <code>count</code></td>
<td>重复 Activity 启动次数</td>
</tr>
<tr>
<td>-S</td>
<td>启动 Activity 前强行停止目标应用</td>
</tr>
<tr>
<td>–opengl-trace</td>
<td>启用 OpenGL 函数的跟踪</td>
</tr>
<tr>
<td>–user <code>user_id</code> | current</td>
<td>指定要作为哪个用户运行；如果未指定，则作为当前用户运行</td>
</tr>
</tbody></table>
<h4 id="4-4-2-调起-Service"><a href="#4-4-2-调起-Service" class="headerlink" title="4.4.2 调起 Service"></a>4.4.2 调起 Service</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;intent&gt;</span><br></pre></td></tr></table></figure>

<p>一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3-停止-Service"><a href="#4-4-3-停止-Service" class="headerlink" title="4.4.3 停止 Service"></a>4.4.3 停止 Service</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am stopservice [options] &lt;intent&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-4-发送广播"><a href="#4-4-4-发送广播" class="headerlink" title="4.4.4 发送广播"></a>4.4.4 发送广播</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>

<p>又例如，只向 <code>com.android.receiver.test/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n com.android.receiver.test/.BootCompletedReceiver</span><br></pre></td></tr></table></figure>

<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi状态变为启用/关闭/正在启动/正在关闭/未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody></table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h4 id="4-4-5-强制停止应用"><a href="#4-4-5-强制停止应用" class="headerlink" title="4.4.5 强制停止应用"></a>4.4.5 强制停止应用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-6-收紧内存"><a href="#4-4-6-收紧内存" class="headerlink" title="4.4.6 收紧内存"></a>4.4.6 收紧内存</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell am send-trim-memory  &lt;pid&gt; &lt;level&gt;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>pid</code>: 进程 ID</li>
<li><code>level</code>:HIDDEN、RUNNING_MODERATE、BACKGROUND、RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE</li>
</ul>
<h3 id="4-5-文件管理"><a href="#4-5-文件管理" class="headerlink" title="4.5 文件管理"></a>4.5 文件管理</h3><h4 id="4-5-1-从模拟器-设备下载指定的文件到计算机"><a href="#4-5-1-从模拟器-设备下载指定的文件到计算机" class="headerlink" title="4.5.1 从模拟器/设备下载指定的文件到计算机"></a>4.5.1 从模拟器/设备下载指定的文件到计算机</h4><p>从模拟器/设备下载指定的文件到计算机的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull &lt;remote&gt; [local]</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>remote</code>: 模拟器/设备里的文件路径</li>
<li><code>local</code>:计算机上的目录，参数可以省略，默认复制到当前目录</li>
</ul>
<p>例如，将 /sdcard/music.mp4 下载到计算机的当前目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/music.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>将 /sdcard/music.mp4 下载到计算机的当前目录(目录需存在)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/music.mp4 D:\Download</span><br></pre></td></tr></table></figure>

<h4 id="4-5-2-将指定的文件从计算机上传到模拟器-设备"><a href="#4-5-2-将指定的文件从计算机上传到模拟器-设备" class="headerlink" title="4.5.2 将指定的文件从计算机上传到模拟器/设备"></a>4.5.2 将指定的文件从计算机上传到模拟器/设备</h4><p>将指定的文件从计算机上传到模拟器/设备的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push &lt;local&gt; &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>local</code>:计算机上的文件路径</li>
<li><code>remote</code>: 模拟器/设备里的目录</li>
</ul>
<p>例如，将 D:\Download\music.mp4 下载到设备的/sdcard/music/目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb push D:\Download\music.mp4 /sdcard/music/</span><br></pre></td></tr></table></figure>

<h4 id="4-5-4-列出指定目录的内容"><a href="#4-5-4-列出指定目录的内容" class="headerlink" title="4.5.4 列出指定目录的内容"></a>4.5.4 列出指定目录的内容</h4><p>列出模拟器/设备上指定目录的内容的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ls [options] &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p>`` 表示指定目录，可以省略，表示列出根目录下的所有文件和目录。 <code>adb shell ls</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>列出目录下的所有文件和目录</td>
</tr>
<tr>
<td>-a</td>
<td>列出目录下的所有文件(包括隐藏的)</td>
</tr>
<tr>
<td>-i</td>
<td>列出目录下的所有文件和索引编号</td>
</tr>
<tr>
<td>-s</td>
<td>列出目录下的所有文件和文件大小</td>
</tr>
<tr>
<td>-n</td>
<td>列出目录下的所有文件及其 UID和 GID</td>
</tr>
<tr>
<td>-R</td>
<td>列出目录下的所有子目录中的文件</td>
</tr>
</tbody></table>
<h4 id="4-5-5-切换到目标目录"><a href="#4-5-5-切换到目标目录" class="headerlink" title="4.5.5 切换到目标目录"></a>4.5.5 切换到目标目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cd &lt;directory&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>cd </code>命令切换到目标目录。</p>
<h4 id="4-5-6-删除文件或目录"><a href="#4-5-6-删除文件或目录" class="headerlink" title="4.5.6 删除文件或目录"></a>4.5.6 删除文件或目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell rm [options] &lt;files or directory&gt;</span><br></pre></td></tr></table></figure>

<p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>rm [options] </code>命令删除文件或目录。</p>
<p><code>rm</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>删除文件</td>
</tr>
<tr>
<td>-f</td>
<td>强制删除文件，系统不提示</td>
</tr>
<tr>
<td>-r</td>
<td>强制删除指定目录中的所有文件和子目录</td>
</tr>
<tr>
<td>-d</td>
<td>删除指定目录，即使它是一个非空目录</td>
</tr>
<tr>
<td>-i</td>
<td>交互式删除，删除前提示</td>
</tr>
</tbody></table>
<p><code>rm -d</code> 等同于 <code>rmdir</code> 命令，有些版本不包含<code>-d</code> 参数。</p>
<h4 id="4-5-7-创建目录"><a href="#4-5-7-创建目录" class="headerlink" title="4.5.7 创建目录"></a>4.5.7 创建目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell mkdir [options] &lt;directory-name&gt;</span><br></pre></td></tr></table></figure>

<p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>mkdir [options] </code>命令创建目录。 <code>mkdir</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>创建指定目录</td>
</tr>
<tr>
<td>-m</td>
<td>创建指定目录并赋予读写权限</td>
</tr>
<tr>
<td>-p</td>
<td>创建指定目录及其父目录</td>
</tr>
</tbody></table>
<h4 id="4-5-8-创建空文件或改变文件时间戳"><a href="#4-5-8-创建空文件或改变文件时间戳" class="headerlink" title="4.5.8 创建空文件或改变文件时间戳"></a>4.5.8 创建空文件或改变文件时间戳</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell touch [options] &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>touch [options] </code>命令创建空文件或改变文件时间戳。</p>
<p>可通过<code>ls -n </code> 命令查看文件的时间。</p>
<h4 id="4-5-9-输出当前目录路径"><a href="#4-5-9-输出当前目录路径" class="headerlink" title="4.5.9 输出当前目录路径"></a>4.5.9 输出当前目录路径</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pwd</span><br></pre></td></tr></table></figure>

<p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>pwd</code>命令输出当前目录路径。</p>
<h4 id="4-5-10-复制文件和目录"><a href="#4-5-10-复制文件和目录" class="headerlink" title="4.5.10 复制文件和目录"></a>4.5.10 复制文件和目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cp [options] &lt;source&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure>

<p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>cp [options]  </code>命令复制文件和目录。 参数说明：</p>
<ul>
<li><code>source</code>:源文件路径</li>
<li><code>dest</code>: 目标文件路径</li>
</ul>
<h4 id="4-5-11-移动或重命名文件"><a href="#4-5-11-移动或重命名文件" class="headerlink" title="4.5.11 移动或重命名文件"></a>4.5.11 移动或重命名文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell mv [options] &lt;source&gt; &lt;dest&gt;</span><br></pre></td></tr></table></figure>

<p>第一步：执行<code>adb shell</code>命令； 第二步：执行<code>mv [options]  </code>命令移动或重命名文件。 参数说明：</p>
<ul>
<li><code>source</code>:源文件路径</li>
<li><code>dest</code>: 目标文件路径</li>
</ul>
<h3 id="4-6-网络管理"><a href="#4-6-网络管理" class="headerlink" title="4.6 网络管理"></a>4.6 网络管理</h3><h4 id="4-6-1-查看网络统计信息"><a href="#4-6-1-查看网络统计信息" class="headerlink" title="4.6.1 查看网络统计信息"></a>4.6.1 查看网络统计信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell netstat</span><br></pre></td></tr></table></figure>

<p>也可以将网络统计信息输出到指定文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell netstat&gt;&lt;file-path&gt;</span><br></pre></td></tr></table></figure>

<p>例如，可以通过 <code>adb shell netstat&gt;D:\netstat.log</code> 将日志输出到 <code>D:\netstat.log</code> 中。</p>
<h4 id="4-6-2-测试两个网络间的连接和延迟"><a href="#4-6-2-测试两个网络间的连接和延迟" class="headerlink" title="4.6.2 测试两个网络间的连接和延迟"></a>4.6.2 测试两个网络间的连接和延迟</h4><p><code>ping</code> 命令的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]</span><br><span class="line">[-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]</span><br><span class="line">[-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]</span><br><span class="line">[-w deadline] [-W timeout] [hop1 ...] destination</span><br></pre></td></tr></table></figure>

<p>例如，ping一个域名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ping www.google.com</span><br></pre></td></tr></table></figure>

<p>不结束的话会一直ping下去，可以按 <code>Ctrl + C</code> 停止ping操作。</p>
<p>也可以指定ping的次数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ping -c 4 www.google.com</span><br></pre></td></tr></table></figure>

<h4 id="4-6-3-通过配置文件配置和管理网络连接"><a href="#4-6-3-通过配置文件配置和管理网络连接" class="headerlink" title="4.6.3 通过配置文件配置和管理网络连接"></a>4.6.3 通过配置文件配置和管理网络连接</h4><p><code>netcfg</code> 命令的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell netcfg [&lt;interface&gt; &#123;dhcp|up|down&#125;]</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmnet_ims10 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_ims00 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun04 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun03 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun02 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun01 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun00 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun14 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun13 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun12 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun11 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_tun10 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet1   DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet0   DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet4   DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet3   DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet2   DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet6   DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet5   DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">dummy0   UP                                     0.0.0.0/0   0x000000c3</span><br><span class="line">rmnet_r_ims10 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_r_ims00 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">rmnet_emc0 DOWN                                   0.0.0.0/0   0x00001002</span><br><span class="line">lo       UP                                   127.0.0.1/8   0x00000049</span><br><span class="line">sit0     DOWN                                   0.0.0.0/0   0x00000080</span><br><span class="line">wlan0    UP                                 10.0.38.176/23  0x00001043</span><br></pre></td></tr></table></figure>

<h4 id="4-6-4-显示、操作路由、设备、策略路由和隧道"><a href="#4-6-4-显示、操作路由、设备、策略路由和隧道" class="headerlink" title="4.6.4 显示、操作路由、设备、策略路由和隧道"></a>4.6.4 显示、操作路由、设备、策略路由和隧道</h4><p><code>ip</code> 命令的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ip [ options ] object</span><br></pre></td></tr></table></figure>

<ul>
<li>options := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]}</li>
<li>object := { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp }</li>
</ul>
<p><code>options</code> 是一些修改ip行为或者改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式，支持的可选参数及含义如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-V,-Version</td>
<td>打印ip的版本并退出</td>
</tr>
<tr>
<td>-s,-stats,-statistics</td>
<td>输出更为详尽的信息(如果这个选项出现两次或者多次，输出的信息将更为详尽)</td>
</tr>
<tr>
<td>-f,-family</td>
<td>强调使用的协议种类(包括：inet、inet6或者link)</td>
</tr>
<tr>
<td>-4</td>
<td>是-family inet的简写</td>
</tr>
<tr>
<td>-6</td>
<td>是-family inet6的简写</td>
</tr>
<tr>
<td>-0</td>
<td>是-family link的简写</td>
</tr>
<tr>
<td>-o,-oneline</td>
<td>对每行记录都使用单行输出，回行用字符代替</td>
</tr>
<tr>
<td>-r,-resolve</td>
<td>查询域名解析系统，用获得的主机名代替主机IP地址</td>
</tr>
</tbody></table>
<p><code>object</code> 是你要管理或者获取信息的对象。目前ip认识的对象包括：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>link</td>
<td>网络设备</td>
</tr>
<tr>
<td>address</td>
<td>一个设备的协议(IP或者IPV6)地址</td>
</tr>
<tr>
<td>neighbour</td>
<td>ARP或者NDISC缓冲区条目</td>
</tr>
<tr>
<td>route</td>
<td>路由表条目</td>
</tr>
<tr>
<td>rule</td>
<td>路由策略数据库中的规则</td>
</tr>
<tr>
<td>maddress</td>
<td>多播地址</td>
</tr>
<tr>
<td>mroute</td>
<td>多播路由缓冲区条目</td>
</tr>
<tr>
<td>tuntap</td>
<td>管理 TUN/TAP 设备</td>
</tr>
<tr>
<td>netns</td>
<td>管理网络空间</td>
</tr>
</tbody></table>
<p>例如，查看 <code>WiFi IP</code> 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ip -f inet addr show wlan0</span><br></pre></td></tr></table></figure>

<h3 id="4-7-模拟按键-输入"><a href="#4-7-模拟按键-输入" class="headerlink" title="4.7 模拟按键/输入"></a>4.7 模拟按键/输入</h3><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。 可以执行<code>adb shell input</code>命令查看完整 help 信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line">The sources are:</span><br><span class="line">      dpad</span><br><span class="line">      keyboard</span><br><span class="line">      mouse</span><br><span class="line">      touchpad</span><br><span class="line">      gamepad</span><br><span class="line">      touchnavigation</span><br><span class="line">      joystick</span><br><span class="line">      touchscreen</span><br><span class="line">      stylus</span><br><span class="line">      trackball</span><br><span class="line">The commands and default sources are:</span><br><span class="line">      text &lt;string&gt; (Default: touchscreen)</span><br><span class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      draganddrop &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      press (Default: trackball)</span><br><span class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br></pre></td></tr></table></figure>

<p>比如使用 <code>adb shell input keyevent </code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放/暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody></table>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h4 id="4-7-1-电源键"><a href="#4-7-1-电源键" class="headerlink" title="4.7.1 电源键"></a>4.7.1 电源键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 26</span><br></pre></td></tr></table></figure>

<p>执行效果相当于按电源键。</p>
<h4 id="4-7-2-菜单键"><a href="#4-7-2-菜单键" class="headerlink" title="4.7.2 菜单键"></a>4.7.2 菜单键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure>

<h4 id="4-7-3-HOME-键"><a href="#4-7-3-HOME-键" class="headerlink" title="4.7.3 HOME 键"></a>4.7.3 HOME 键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 3</span><br></pre></td></tr></table></figure>

<h4 id="4-7-4-返回键"><a href="#4-7-4-返回键" class="headerlink" title="4.7.4 返回键"></a>4.7.4 返回键</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 4</span><br></pre></td></tr></table></figure>

<h4 id="4-7-5-音量控制"><a href="#4-7-5-音量控制" class="headerlink" title="4.7.5 音量控制"></a>4.7.5 音量控制</h4><ul>
<li>增加音量：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 24</span><br></pre></td></tr></table></figure>

<ul>
<li>降低音量：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure>

<ul>
<li>静音：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 164</span><br></pre></td></tr></table></figure>

<h4 id="4-7-6-媒体控制"><a href="#4-7-6-媒体控制" class="headerlink" title="4.7.6 媒体控制"></a>4.7.6 媒体控制</h4><ul>
<li>播放/暂停：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 85</span><br></pre></td></tr></table></figure>

<ul>
<li>停止播放：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 86</span><br></pre></td></tr></table></figure>

<ul>
<li>播放下一首：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 87</span><br></pre></td></tr></table></figure>

<ul>
<li>播放上一首：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 88</span><br></pre></td></tr></table></figure>

<ul>
<li>恢复播放：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 126</span><br></pre></td></tr></table></figure>

<ul>
<li>暂停播放：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 127</span><br></pre></td></tr></table></figure>

<h4 id="4-7-7-点亮-熄灭屏幕"><a href="#4-7-7-点亮-熄灭屏幕" class="headerlink" title="4.7.7 点亮/熄灭屏幕"></a>4.7.7 点亮/熄灭屏幕</h4><ul>
<li>点亮屏幕：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 224</span><br></pre></td></tr></table></figure>

<ul>
<li>熄灭屏幕：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 223</span><br></pre></td></tr></table></figure>

<h4 id="4-7-8-滑动解锁"><a href="#4-7-8-滑动解锁" class="headerlink" title="4.7.8 滑动解锁"></a>4.7.8 滑动解锁</h4><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure>

<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h4 id="4-7-9-输入文本"><a href="#4-7-9-输入文本" class="headerlink" title="4.7.9 输入文本"></a>4.7.9 输入文本</h4><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure>

<h3 id="4-8-日志打印"><a href="#4-8-日志打印" class="headerlink" title="4.8 日志打印"></a>4.8 日志打印</h3><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p>
<h4 id="4-8-1-Android-日志"><a href="#4-8-1-Android-日志" class="headerlink" title="4.8.1 Android 日志"></a>4.8.1 Android 日志</h4><p>查看 Android 设备系统属性的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat [option] [filter-specs]</span><br></pre></td></tr></table></figure>

<p>如果需要停止 <code>logcat</code> 日志打印，可以按 <code>Ctrl + C</code> 停止日志监控。</p>
<h5 id="4-8-1-1-按级别过滤日志"><a href="#4-8-1-1-按级别过滤日志" class="headerlink" title="4.8.1.1 按级别过滤日志"></a>4.8.1.1 按级别过滤日志</h5><p>按级别过滤日志的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat [filter-specs]</span><br></pre></td></tr></table></figure>

<p>Android 的日志分为如下几个优先级（priority）：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*:V</td>
<td>过滤只显示 Verbose 及以上级别(优先级最低)</td>
</tr>
<tr>
<td>*:D</td>
<td>过滤只显示 Debug 及以上级别</td>
</tr>
<tr>
<td>*:I</td>
<td>过滤只显示 Info 及以上级别</td>
</tr>
<tr>
<td>*:W</td>
<td>过滤只显示 Warning 及以上级别</td>
</tr>
<tr>
<td>*:E</td>
<td>过滤只显示 Error 及以上级别</td>
</tr>
<tr>
<td>*:F</td>
<td>过滤只显示 Fatal 及以上级别</td>
</tr>
<tr>
<td>*:S</td>
<td>过滤只显示 Silent 及以上级别(优先级最高，什么也不输出)</td>
</tr>
</tbody></table>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure>

<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h5 id="4-8-1-2-按-tag-和级别过滤日志"><a href="#4-8-1-2-按-tag-和级别过滤日志" class="headerlink" title="4.8.1.2 按 tag 和级别过滤日志"></a>4.8.1.2 按 tag 和级别过滤日志</h5><p>按 tag 和级别过滤日志的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat [tag:level] [tag:level] ...</span><br></pre></td></tr></table></figure>

<p>比如，命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure>

<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h5 id="4-8-1-3-将日志格式化输出"><a href="#4-8-1-3-将日志格式化输出" class="headerlink" title="4.8.1.3 将日志格式化输出"></a>4.8.1.3 将日志格式化输出</h5><p>可以用 <code>adb logcat -v </code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 ``：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示格式</th>
</tr>
</thead>
<tbody><tr>
<td>brief</td>
<td><code>/(): </code></td>
</tr>
<tr>
<td>process</td>
<td><code>() </code></td>
</tr>
<tr>
<td>tag</td>
<td><code>/: </code></td>
</tr>
<tr>
<td>raw</td>
<td>``</td>
</tr>
<tr>
<td>time</td>
<td><code>/():</code></td>
</tr>
<tr>
<td>threadtime</td>
<td><code>   :</code></td>
</tr>
<tr>
<td>long</td>
<td><code>[  : / ] </code></td>
</tr>
</tbody></table>
<p>日志格式默认为 <code>brief</code>，指定格式可与上面的过滤同时使用。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -v long ActivityManager:I *:S</span><br></pre></td></tr></table></figure>

<h5 id="4-8-1-3-清空已存在的日志"><a href="#4-8-1-3-清空已存在的日志" class="headerlink" title="4.8.1.3 清空已存在的日志"></a>4.8.1.3 清空已存在的日志</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></table></figure>

<h5 id="4-8-1-4-将日志显示在控制台"><a href="#4-8-1-4-将日志显示在控制台" class="headerlink" title="4.8.1.4 将日志显示在控制台"></a>4.8.1.4 将日志显示在控制台</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -d</span><br></pre></td></tr></table></figure>

<h5 id="4-8-1-5-将日志输出到文件"><a href="#4-8-1-5-将日志输出到文件" class="headerlink" title="4.8.1.5 将日志输出到文件"></a>4.8.1.5 将日志输出到文件</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -f &lt;file-path&gt;</span><br></pre></td></tr></table></figure>

<h5 id="4-8-1-6-加载一个可使用的日志缓冲区供查看"><a href="#4-8-1-6-加载一个可使用的日志缓冲区供查看" class="headerlink" title="4.8.1.6 加载一个可使用的日志缓冲区供查看"></a>4.8.1.6 加载一个可使用的日志缓冲区供查看</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -b &lt;Buffer&gt;</span><br></pre></td></tr></table></figure>

<p><code>Android log</code> 输出量巨大，特别是通信系统的log，因此，Android把log输出到不同的缓冲区中，目前定义了四个log缓冲区：</p>
<table>
<thead>
<tr>
<th>缓冲区</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Radio</td>
<td>输出通信系统的 log</td>
</tr>
<tr>
<td>System</td>
<td>输出系统组件的 log</td>
</tr>
<tr>
<td>Event</td>
<td>输出 event 模块的 log</td>
</tr>
<tr>
<td>Main</td>
<td>所有 java 层的 log 以及不属于上面3层的 log</td>
</tr>
</tbody></table>
<p>缓冲区主要给系统组件使用，一般的应用不需要关心，应用的log都输出到main缓冲区中。默认log输出（不指定缓冲区的情况下）是输出System和Main缓冲区的log。</p>
<h5 id="4-8-1-7-打印指定日志缓冲区的大小"><a href="#4-8-1-7-打印指定日志缓冲区的大小" class="headerlink" title="4.8.1.7 打印指定日志缓冲区的大小"></a>4.8.1.7 打印指定日志缓冲区的大小</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat -g</span><br></pre></td></tr></table></figure>

<h4 id="4-8-2-内核日志"><a href="#4-8-2-内核日志" class="headerlink" title="4.8.2 内核日志"></a>4.8.2 内核日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dmesg</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs</span><br><span class="line">&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs</span><br><span class="line">&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs</span><br><span class="line">&lt;4&gt;[14201.755954] Restarting tasks ... done.</span><br><span class="line">&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC</span><br><span class="line">&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC</span><br><span class="line">&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done.</span><br></pre></td></tr></table></figure>

<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h3 id="4-9-查看-Android-设备系统属性"><a href="#4-9-查看-Android-设备系统属性" class="headerlink" title="4.9 查看 Android 设备系统属性"></a>4.9 查看 Android 设备系统属性</h3><p>查看 Android 设备系统属性的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop [options]</span><br></pre></td></tr></table></figure>

<p>除了可以查看 Android 设备系统属性之外，还可以设置系统属性，设置系统属性的基本命令格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell setprop &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-9-1-查看设备型号"><a href="#4-9-1-查看设备型号" class="headerlink" title="4.9.1 查看设备型号"></a>4.9.1 查看设备型号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Nexus 5</span><br></pre></td></tr></table></figure>

<h4 id="4-9-2-查看设备电池状况"><a href="#4-9-2-查看设备电池状况" class="headerlink" title="4.9.2 查看设备电池状况"></a>4.9.2 查看设备电池状况</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Current Battery Service state:</span><br><span class="line">  AC powered: false</span><br><span class="line">  USB powered: true</span><br><span class="line">  Wireless powered: false</span><br><span class="line">  status: 2</span><br><span class="line">  health: 2</span><br><span class="line">  present: true</span><br><span class="line">  level: 44</span><br><span class="line">  scale: 100</span><br><span class="line">  voltage: 3872</span><br><span class="line">  temperature: 280</span><br><span class="line">  technology: Li-poly</span><br></pre></td></tr></table></figure>

<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h4 id="4-9-3-查看设备屏幕分辨率"><a href="#4-9-3-查看设备屏幕分辨率" class="headerlink" title="4.9.3 查看设备屏幕分辨率"></a>4.9.3 查看设备屏幕分辨率</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br></pre></td></tr></table></figure>

<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br><span class="line">Override size: 480x1024</span><br></pre></td></tr></table></figure>

<p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p>
<h4 id="4-9-4-查看设备屏幕密度"><a href="#4-9-4-查看设备屏幕密度" class="headerlink" title="4.9.4 查看设备屏幕密度"></a>4.9.4 查看设备屏幕密度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm density</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Physical density: 420</span><br></pre></td></tr></table></figure>

<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Physical density: 480</span><br><span class="line">Override density: 160</span><br></pre></td></tr></table></figure>

<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h4 id="4-9-5-查看设备显示屏参数"><a href="#4-9-5-查看设备显示屏参数" class="headerlink" title="4.9.5 查看设备显示屏参数"></a>4.9.5 查看设备显示屏参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</span><br><span class="line">  Display: mDisplayId=0</span><br><span class="line">    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</span><br><span class="line">    deferred=false layoutNeeded=false</span><br></pre></td></tr></table></figure>

<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p>
<h4 id="4-9-6-查看设备-android-id"><a href="#4-9-6-查看设备-android-id" class="headerlink" title="4.9.6 查看设备 android_id"></a>4.9.6 查看设备 android_id</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings get secure android_id</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">51b6be48bac8c569</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-9-7-查看设备IMEI"><a href="#4-9-7-查看设备IMEI" class="headerlink" title="4.9.7 查看设备IMEI"></a>4.9.7 查看设备IMEI</h4><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys iphonesubinfo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Phone Subscriber Info:</span><br><span class="line">  Phone Type = GSM</span><br><span class="line">  Device ID = 860955027785041</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">service call iphonesubinfo 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p>
<h4 id="4-9-8-查看设备-Android-系统版本"><a href="#4-9-8-查看设备-Android-系统版本" class="headerlink" title="4.9.8 查看设备 Android 系统版本"></a>4.9.8 查看设备 Android 系统版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.0.2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-9-9-查看设备-IP-地址"><a href="#4-9-9-查看设备-IP-地址" class="headerlink" title="4.9.9 查看设备 IP 地址"></a>4.9.9 查看设备 IP 地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig wlan0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell netcfg</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-9-10-查看设备-Mac-地址"><a href="#4-9-10-查看设备-Mac-地址" class="headerlink" title="4.9.10 查看设备 Mac 地址"></a>4.9.10 查看设备 Mac 地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /sys/class/net/wlan0/address</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f8:a9:d0:17:42:4d</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h4 id="4-9-11-查看设备-CPU-信息"><a href="#4-9-11-查看设备-CPU-信息" class="headerlink" title="4.9.11 查看设备 CPU 信息"></a>4.9.11 查看设备 CPU 信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-9-12-查看设备内存信息"><a href="#4-9-12-查看设备内存信息" class="headerlink" title="4.9.12 查看设备内存信息"></a>4.9.12 查看设备内存信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /proc/meminfo</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-9-13-查看设备更多硬件与系统属性"><a href="#4-9-13-查看设备更多硬件与系统属性" class="headerlink" title="4.9.13 查看设备更多硬件与系统属性"></a>4.9.13 查看设备更多硬件与系统属性</h4><p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /system/build.prop</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td><a href="http://ro.product.name/">ro.product.name</a></td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody></table>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell cat /system/build.prop | grep ro.product.cpu.abi</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ro.product.cpu.abi=armeabi-v7a</span><br><span class="line">ro.product.cpu.abi2=armeabi</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="4-10-修改设置"><a href="#4-10-修改设置" class="headerlink" title="4.10 修改设置"></a>4.10 修改设置</h3><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p>
<h4 id="4-10-1-修改分辨率"><a href="#4-10-1-修改分辨率" class="headerlink" title="4.10.1 修改分辨率"></a>4.10.1 修改分辨率</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm size 480x1024</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-10-2-修改屏幕密度"><a href="#4-10-2-修改屏幕密度" class="headerlink" title="4.10.2 修改屏幕密度"></a>4.10.2 修改屏幕密度</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm density 160</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm density reset</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-10-3-修改显示区域"><a href="#4-10-3-修改显示区域" class="headerlink" title="4.10.3 修改显示区域"></a>4.10.3 修改显示区域</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan 0,0,0,200</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan reset</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-10-4-修改关闭-USB-调试模式"><a href="#4-10-4-修改关闭-USB-调试模式" class="headerlink" title="4.10.4 修改关闭 USB 调试模式"></a>4.10.4 修改关闭 USB 调试模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global adb_enabled 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h4 id="4-10-5-修改允许-禁止访问非-SDK-API"><a href="#4-10-5-修改允许-禁止访问非-SDK-API" class="headerlink" title="4.10.5 修改允许/禁止访问非 SDK API"></a>4.10.5 修改允许/禁止访问非 SDK API</h4><p>允许访问非 SDK API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global hidden_api_policy_pre_p_apps 1</span><br><span class="line">adb shell settings put global hidden_api_policy_p_apps 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>禁止访问非 SDK API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings delete global hidden_api_policy_pre_p_apps</span><br><span class="line">adb shell settings delete global hidden_api_policy_p_apps</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>不需要设备获得 Root 权限。</p>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td>禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody></table>
<h4 id="4-10-6-修改状态栏和导航栏的显示隐藏"><a href="#4-10-6-修改状态栏和导航栏的显示隐藏" class="headerlink" title="4.10.6 修改状态栏和导航栏的显示隐藏"></a>4.10.6 修改状态栏和导航栏的显示隐藏</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control &lt;key-values&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>`` 可由如下几种键及其对应的值组成，格式为 <code>=:=</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody></table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>package-name</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-package-name</code></td>
<td>排除指定应用</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.full=*</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h3 id="4-11-实用功能"><a href="#4-11-实用功能" class="headerlink" title="4.11 实用功能"></a>4.11 实用功能</h3><h4 id="4-11-1-屏幕截图"><a href="#4-11-1-屏幕截图" class="headerlink" title="4.11.1 屏幕截图"></a>4.11.1 屏幕截图</h4><p>截图保存到电脑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p>
<p>先截图保存到设备里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/sc.png</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后将 png 文件导出到电脑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sc.png</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody></table>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>另外一种一行命令截图并保存到电脑的方法： <em>Linux 和 Windows</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | sed &quot;s/\r$//&quot; &gt; sc.png</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><em>Mac OS X</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | gsed &quot;s/\r$//&quot; &gt; sc.png</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed: RE error: illegal byte sequence</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install gnu-sed</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-11-2-录制屏幕"><a href="#4-11-2-录制屏幕" class="headerlink" title="4.11.2 录制屏幕"></a>4.11.2 录制屏幕</h4><p>录制屏幕以 mp4 格式保存到 /sdcard：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody></table>
<h4 id="4-11-3-查看连接过的-WiFi-密码"><a href="#4-11-3-查看连接过的-WiFi-密码" class="headerlink" title="4.11.3 查看连接过的 WiFi 密码"></a>4.11.3 查看连接过的 WiFi 密码</h4><p><strong>注：需要 root 权限。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">cat /data/misc/wifi/*.conf</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-11-4-设置系统日期和时间"><a href="#4-11-4-设置系统日期和时间" class="headerlink" title="4.11.4 设置系统日期和时间"></a>4.11.4 设置系统日期和时间</h4><p><strong>注：需要 root 权限。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">date -s 20160823.131500</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h4 id="4-11-5-重启手机"><a href="#4-11-5-重启手机" class="headerlink" title="4.11.5 重启手机"></a>4.11.5 重启手机</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-11-6-检测设备是否已-root"><a href="#4-11-6-检测设备是否已-root" class="headerlink" title="4.11.6 检测设备是否已 root"></a>4.11.6 检测设备是否已 root</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h4 id="4-11-7-使用-Monkey-进行压力测试"><a href="#4-11-7-使用-Monkey-进行压力测试" class="headerlink" title="4.11.7 使用 Monkey 进行压力测试"></a>4.11.7 使用 Monkey 进行压力测试</h4><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure>

<p>表示向 `` 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">官方文档</a>。</p>
<h4 id="4-11-8-开启-关闭-WiFi"><a href="#4-11-8-开启-关闭-WiFi" class="headerlink" title="4.11.8 开启/关闭 WiFi"></a>4.11.8 开启/关闭 WiFi</h4><p><strong>注：需要 root 权限。</strong></p>
<ul>
<li>开启 WiFi：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi enable</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭 WiFi：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi disable</span><br></pre></td></tr></table></figure>

<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h3 id="4-12-刷机相关命令"><a href="#4-12-刷机相关命令" class="headerlink" title="4.12 刷机相关命令"></a>4.12 刷机相关命令</h3><h4 id="4-12-1-重启到-Recovery-模式"><a href="#4-12-1-重启到-Recovery-模式" class="headerlink" title="4.12.1 重启到 Recovery 模式"></a>4.12.1 重启到 Recovery 模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>

<h4 id="4-12-2-从-Recovery-重启到-Android"><a href="#4-12-2-从-Recovery-重启到-Android" class="headerlink" title="4.12.2 从 Recovery 重启到 Android"></a>4.12.2 从 Recovery 重启到 Android</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>

<h4 id="4-12-2-重启到-Fastboot-模式"><a href="#4-12-2-重启到-Fastboot-模式" class="headerlink" title="4.12.2 重启到 Fastboot 模式"></a>4.12.2 重启到 Fastboot 模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>

<h4 id="4-12-4-通过-sideload-更新系统"><a href="#4-12-4-通过-sideload-更新系统" class="headerlink" title="4.12.4 通过 sideload 更新系统"></a>4.12.4 通过 sideload 更新系统</h4><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li>重启到 Recovery 模式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>

<ol>
<li>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</li>
<li>通过 adb 上传和更新系统。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload &lt;path-to-update.zip&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-13-安全相关命令"><a href="#4-13-安全相关命令" class="headerlink" title="4.13 安全相关命令"></a>4.13 安全相关命令</h3><h4 id="4-13-1-启用-禁用-SELinux"><a href="#4-13-1-启用-禁用-SELinux" class="headerlink" title="4.13.1 启用/禁用 SELinux"></a>4.13.1 启用/禁用 SELinux</h4><p>启用 SELinux</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 1</span><br></pre></td></tr></table></figure>

<p>禁用 SELinux</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure>

<h4 id="4-13-2-启用-禁用-dm-verity"><a href="#4-13-2-启用-禁用-dm-verity" class="headerlink" title="4.13.2 启用/禁用 dm_verity"></a>4.13.2 启用/禁用 dm_verity</h4><p>启用 dm_verity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb enable-verity</span><br></pre></td></tr></table></figure>

<p>禁用 dm_verity</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb disable-verity</span><br></pre></td></tr></table></figure>

<h3 id="4-14-更多-adb-shell-命令"><a href="#4-14-更多-adb-shell-命令" class="headerlink" title="4.14 更多 adb shell 命令"></a>4.14 更多 adb shell 命令</h3><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h4 id="4-14-1-查看进程状态"><a href="#4-14-1-查看进程状态" class="headerlink" title="4.14.1 查看进程状态"></a>4.14.1 查看进程状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell ps</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>输出信息各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<h4 id="4-14-2-查看处理器实时状态"><a href="#4-14-2-查看处理器实时状态" class="headerlink" title="4.14.2 查看处理器实时状态"></a>4.14.2 查看处理器实时状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell top [-m max_procs] [-n iterations] [-d delay] [-s sort_column] [-t] [-h]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>adb shell top</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-m</td>
<td>最多显示多少个进程</td>
</tr>
<tr>
<td>-n</td>
<td>刷新多少次后退出</td>
</tr>
<tr>
<td>-d</td>
<td>刷新时间间隔(单位秒，默认值5)</td>
</tr>
<tr>
<td>-s</td>
<td>按某列排序(可用col值：cpu, vss, rss, thr)</td>
</tr>
<tr>
<td>-t</td>
<td>显示线程信息</td>
</tr>
<tr>
<td>-h</td>
<td>显示帮助文档</td>
</tr>
</tbody></table>
<p>输出信息各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<h4 id="4-14-3-查看进程-UID"><a href="#4-14-3-查看进程-UID" class="headerlink" title="4.14.3 查看进程 UID"></a>4.14.3 查看进程 UID</h4><p>有两种方案：</p>
<ol>
<li><code>adb shell dumpsys package  | grep userId=</code> 如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys package org.mazhuang.guanggoo | grep userId=</span><br><span class="line">  userId=10394</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc//status | grep Uid</code> 如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">gemini:/ $ ps | grep org.mazhuang.guanggoo</span><br><span class="line">u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo</span><br><span class="line">gemini:/ $ cat /proc/28635/status | grep Uid</span><br><span class="line">Uid:    10394   10394   10394   10394</span><br><span class="line">gemini:/ $</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="五、致谢"><a href="#五、致谢" class="headerlink" title="五、致谢"></a>五、致谢</h2><ol>
<li><p><a href="http://adbshell.com/">ADB Shell</a></p>
</li>
<li><p><a href="https://github.com/mzlogin/awesome-adb">Awesome Adb</a></p>
</li>
<li><p><a href="https://developer.android.com/studio/command-line/adb">Android Debug Bridge</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>使用手册</tag>
      </tags>
  </entry>
  <entry>
    <title>页面丢失啦🙈</title>
    <url>//404.html</url>
    <content><![CDATA[<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="renderer" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>该页面不存在-404.life</title>
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/payiz-asj/CDN@4.05/404/favicon.ico">
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/payiz-asj/CDN@4.05/404/css/404life.css" />
</head>
<body>
<div class="tcy_404 container">
<img src="https://cdn.jsdelivr.net/gh/payiz-asj/CDN@4.05/404/picture/404.png">
<h2>抱歉，您访问的页面出错了</h2>
<p>您可能输错了网址，或该网页已删除或不存在</p>
<a href="https://yeying.tech" class="btn btn-primary btn_blue">返回主页</a>
</div>
</body>
</html>



]]></content>
  </entry>
  <entry>
    <title>个人介绍</title>
    <url>/about/me.html</url>
    <content><![CDATA[<!-- 标题部分 

<h1 align="center">个人介绍</h1>
-->

<!-- 个人介绍 -->

<h3 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h3><ul>
<li><p> 南京大学计算机科学与技术系本科生 .🎓</p>
</li>
<li><p> 软件开发工程师 .👨‍💻</p>
</li>
<li><p> <strong>技术栈 :</strong></p>
</li>
<li><p>前端: HTML 5+CSS+JS, Wechat Mini Program.</p>
</li>
<li><p>后端: Linux, Python, C++, C#, VB, Web crawler, scientific operation, data analysis.</p>
</li>
<li><p>数据库: Sql Server 2018 , Sqlite.</p>
</li>
<li><p>喜欢的开发环境: JetBrains Family Bucket (Especially PyCharm, WebStorm, IntelliJ IDEA ), Visual Studio 2019, VMware Workstation, Sublime Text3, Typora.</p>
</li>
<li><p>一些喜欢的开发工具: Github, Gitee, Selenium, Scrapy,  postman, Fiddler.</p>
</li>
<li><p>其他: Adobe Family Bucket(Especially PS, PR, AU, XD), My Laptop💻, My Android Phone📱.</p>
</li>
<li><p><strong>个人爱好:</strong></p>
<ul>
<li>听音乐</li>
<li>写代码</li>
<li>足球、篮球</li>
</ul>
<!-- 动图效果 -->

<div align="right"  >-----------LOVE YOU KOBE R.I.P❤-----------</div>
  <a href="#" align="right">
      <img align="right" src="https://pic.imgdb.cn/item/61015ffd5132923bf89e6c47.gif" alt="图片裂开了？这里本该显示一个gif的"/>     
  </a>     </li>
<li><p><strong>目前专注于:</strong></p>
<ul>
<li>计算机算法</li>
<li>网页设计, 网页爬虫r</li>
<li>自然语言处理</li>
</ul>
</li>
<li><p><strong>近期愿望:</strong></p>
<ul>
<li> 毕业之际，我正在申请软件工程相关的工作 .💌</li>
</ul>
</li>
</ul>
<!-- 后记 -->

<h3 id="More"><a href="#More" class="headerlink" title="More:"></a>More:</h3><p><strong>💬 欢迎您来到我的 <a href="https://github.com/payiz-asj">GIthub</a> 和 我的个人博客: <a href="https://yeying.tech/">夜莺悠吟 </a></strong></p>
]]></content>
  </entry>
  <entry>
    <title>博客介绍</title>
    <url>/about/site.html</url>
    <content><![CDATA[<!-- 标题部分 

<h1 align="center">博客介绍</h1>
-->

<!-- 博客介绍 --> 

<p>​        此博客的建立初衷，是想记录我的所见所闻、学到的知识、遇到的问题，并将有价值的知识、有趣的事物分享给他人，希望大家能从中受益！😉   </p>
<h2 align="center">博客名字的寓意</h2>
​        博客名字：夜莺悠吟      
​        灵感来自下面的故事：  

<h3 align="center">织梦使者-夜莺, 代号04:00:00</h3>
​        这几日，天天熬夜折腾，在搭建个人博客。经过3天3夜的努力，现在倒是完成了基本框架、撰写了几篇文章，就差一个好听一点的博客名字，就可以买域名、部署、上线了！想来想去又熬到深更半夜...            
​        感到眼睛有些疲劳的我，又跟往常一样，去阳台清静清静......     
​        忽然，听到远处传来一个悠长的鸟鸣声，接着，那声音越来越近....那声音是那么的悠然，清脆！仿佛仙界歌声一般！   

<p>​        用心聆听……<br>​        沉浸在歌声中，完全没发现小鸟已经飞到自己身边，就在身旁悠悠吟唱！   </p>
<p>​        小鸟唱完，我…，许久没有说话，脑子里就像漫无边际的大自然，空旷、宁静，身体感到极其放松、舒适……<br>过了一会儿，小鸟主动介绍自己，说自己是一个高维生物，名字叫夜莺，职业是织梦使者，代号是04:00:00。它的工作是夜晚04:00:00巡逻全世界，随机挑选一个和自己性格相同的人类，让他或她体验高维生物的生活。</p>
<p>此外，还给我介绍了一下高维生物：<br>地球上已知的生命体都是三维生物，其实还存在高维生物，我们察觉不到而已！<br>高维生物中，有一个职业叫做织梦使者，专门为三维生物编制梦！（主要是给人类）<br>在职数量86400个，即：24*60*60=86400，每秒一位使者工作，全世界范围内挑选一名与自己的性格相同的人类织梦，等对方体验完梦境后，删除相关记忆！<br>织梦使者形态跟三维生物差不多，有人的形态，也有动物、植物，但是不重复，比如，夜莺只有一个！</p>
<p>夜莺每晚04:00:00工作，它的风格是喜欢自由，勤奋，励志。<br>它会每晚这个时间点，在全世界范围内挑选性格与它相同的人类织梦，让他或她拥有高维生物的能力，尽情绽放自己的想象力！</p>
<p>​        今晚是刚好挑选到我……</p>
<p>​        我看看手机上的表，刚出来阳台时就是凌晨3点58来着，现在一根烟抽完，还听了这么久的歌声，时间停在04:00:00，是手机出问题了？还是夜莺真的让时间停止了？？？   </p>
<p>​        夜莺微笑的点头说：是的，我让时间暂停了，等我工作结束后，时间就会是下一个织梦使者的了。<br>​        下面我给你介绍一下我们高维生物的生活吧~~    </p>
<p>高维生物的能力：能够控制宇宙基本粒子</p>
<p>他们很强大，基于上述能力，他们可以衍生出以下技能：<br>超光速移动<br>控制时间（包括时光穿梭和回流）<br>重生，永生<br>隐身，<br>制作、修改、删除记忆<br>其他……</p>
<p>​        夜莺说着，在我头上点了一下，我感受到脑海顿时被无数个记忆充满，身体也突然发烫……</p>
<p>​        过了一会儿，我逐渐意识自己拥有了控制宇宙粒子的能力！！！   </p>
<p>​        掌握后，我迫不及待地体验了一下，真的能让我隐身、让我身高变成180哎！！！<br>那试试瞬移？呵，心中意念一动，我立刻出现我们学校图书馆！信念再一动，我开始以量子速度阅读书籍，几分钟就把图书馆所有书籍都记到脑子里了….<br>​       哇！这也太强大了吧！<br>​       我动用时间修改能力，让来年夏天提前到来并瞬移到世界各地旅游……<br>​       多年后，我做出了很多科技，天文，物理方面的大发明、大贡献！给全世界证明了自己的同时，让人类进入了全新的宇宙航海时代！<br>​    </p>
<p>​        但是，功成名就的我，偶尔会特别伤心…..</p>
<p>​        这一切成就来得如此简单，以至于我都感觉不到我给人类到底做了什么，我做了什么？啊，这些都是我做的吗？</p>
<p>​        我想到我高中时的人生格言：<strong>奇迹是努力的另一个名字</strong></p>
<p>​        对啊！</p>
<p>​        曾经我坚持不懈的努力，到最后就算没有成功，心里也是开心的！</p>
<p>​        </p>
<p>​        瘦如干柴的身躯，慢慢地施展时间回流的能力，心里想着：“人生本应经历酸甜苦辣，仔细品味，一步一步，脚踏实地……”，大呵一声：“回到这一切的开始吧！”</p>
<p>​        重新出现在记忆中那个阳台，深邃的眼睛重新变得清澈、坚定！</p>
<p>​        就在此时，又听到夜莺缓缓悠吟……</p>
<p>我问：<br>你要走了吗？</p>
<p>夜莺:<br>嗯，我也很高兴认识你。非常喜欢你的表现 ，也说明我没有选错人！没有超能力又如何，努力活出自我才最重要！<br>现在该是织梦使者04:00:01的时间了，我该回去休息了。</p>
<p>我问：<br>以后有机会再相遇吗？</p>
<p>夜莺：<br>看缘分吧！每个人身上的性格都很复杂的，你身上的主要性格与我相似不代表你没有别的性格，也许你还能遇到别的织梦使者呢！体验一下别的梦也不错呦~~</p>
<p>对了，你今晚的部分记忆我会删除哦，抱歉&lt;(_ _)&gt;<br>再见了！保重！<br>        ……<br>        ……   </p>
<p>我：</p>
<p>​        刚才好像听到了个很美妙的歌声？可是这大半夜谁会唱歌啊？？</p>
<p>回到座位……<br>咦！电脑屏幕上何时出现这四个字？？</p>
<p>​                      <strong>夜莺悠吟</strong></p>
<p>哇！博客名字就选这个了！！！</p>
<p>［夜莺，谢谢你！］</p>
]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>friends</title>
    <url>/friends/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2020 东京奥运会</title>
    <url>/olympic/olympic.html</url>
    <content><![CDATA[<h1 align="center">中国加油 💪💖💖</h1>
上次更新时间：2021-07-30 17:09:54

<h2 align="center">奖牌榜</h>
![奖牌榜](https://www.screenshotmaster.com/api/v1/screenshot?url=https://tiyu.baidu.com/tokyoly/home/tab/%E5%A5%96%E7%89%8C%E6%A6%9C&token=61026ce09e50e&full_page=0&device=pc&retina=1)



<p>阅读更多，以查看更多信息 👉</p>
<span id="more"></span>

<h2 align="center">今日热门赛事</h>

<p><img src="https://www.screenshotmaster.com/api/v1/screenshot?url=https://tiyu.baidu.com/tokyoly/home/tab/%E8%B5%9B%E7%A8%8B/type/hot&token=61026ce09e50e&full_page=1&device=pc&retina=1" alt="热门赛程"></p>
]]></content>
  </entry>
  <entry>
    <title>《Y 你》</title>
    <url>/photos/index%20-%20%E5%89%AF%E6%9C%AC.html</url>
    <content><![CDATA[<h2 align="center" >《Y 你》</h2>
<p align="center">艾亭湖边看晚霞，紫金之巅望险崖。</p>
<p align="center">小快身边幸有他，驰骋天下从不怕。</p>
<p align="center">呆子与你永相伴，无畏春寒夏日炎。</p>
<p align="center">巴卜可愿为57， 1314Y你。</p>






]]></content>
  </entry>
  <entry>
    <title>《Y 你》</title>
    <url>/photos/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
